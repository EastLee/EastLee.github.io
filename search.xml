<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[webpack.plugin]]></title>
      <url>http://yoursite.com/2016/10/18/webpack-plugin/</url>
      <content type="text"><![CDATA[bell-on-bundler-error-pluginbell-on-bundler-error-plugin会通知您在打包构建过程中的错误function BellOnBundlerErrorPlugin () &#123; &#125;BellOnBundlerErrorPlugin.prototype.apply = function(compiler) &#123; if (typeof(process) !== 'undefined')&#123; compiler.plugin('done', function(stats) &#123; if (stats.hasErrors()) process.stderr.write('\x07') &#125;) compiler.plugin('failed', function(err) &#123; process.stderr.write('\x07') &#125;) &#125;&#125;module.exports = BellOnBundlerErrorPlugin CommonsChunkPluginWebpack中将打包后的文件都称之为“Chunk”。这个插件可以将多个打包后的资源中的公共部分打包成单独的文件。智能提取公共部分来方便多页面之间进行复用!先看一个简单的例子，运行一下，从下图可知，公共部分已经被独立出来，在html必须先被加载！提取的公共部分的common，还可以再和其他文件继续提取common，来看一个稍微复杂的例子,在index.html中改变js的引用文件，就可以看见效果！ page5.html: commons.js, ap1.js page4.html: commons.js, ap2.js page3.html: p3.js page2.html: commons.js, admin-commons.js, p1.js page1.html: commons.js, admin-commons.js, p2.js extract-text-webpack-plugin独立出css样式，单独打包CSS，通过link引入样式而不是放在style标签内 ExtractTextPlugin.extract([notExtractLoader], loader, [options]) noExtractLoader可选参数，未提取的css会被这个loader处理。loader列表，将资源转换为导出的css module，必选ExtractTextPlugin.extract会在这个loader列表前插入一个loader，并且最后会执行loader列表所返回的module,本人尝试这个插件，无论同一个入口中引入多少css文件，都被打包成一个css，不同的入口会单独打包一个，看一个例子，在这个例子中还增加了压缩js的功能。 webpack.DefinePlugin可以为js定义变量，这个变量是webpack自动生成插入到我们的代码中的new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV:JSON.stringify(env) &#125;, __DEV__:dev&#125;) DefinePlugin中可以传入一个对象，对象的key会被定义在我们的代码中，对应的value，就是key在代码中对应的值，值得注意的是字符串需要JSON.stringify包裹，否则这个值在代码中会生成一个变量，而不是字符串，导致代码报错，看个例子！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack.learning]]></title>
      <url>http://yoursite.com/2016/10/17/webpack-learning/</url>
      <content type="text"><![CDATA[安装Node作为前端，没用过Node，只能说是个十足的菜鸟！ 全局安装webpack$ npm install webpack -g 运行例子进入文件，首先运行 npm install，安装所需要的依赖，然后可以打开example1.webpack文件夹，运行下面的命令：$ webpack src/index.js dist/index.js 之后打开index.html就可以看见运行效果！ 生成配置文件webpack.config.js查看第二个例子,进入文件，只要运行如下命令即可，$ webpack 此时webpack就会自动运行这个配置文件,如果想配置多个config文件，用如下命令：$ webpack --config webpack.config.prod.js 编译React安装一下插件$ npm install babel-loader babel-core babel-preset-es2015 babel-preset-stage-0 babel-preset-react babel-polyfill --save-dev$ npm install react react-dom --save babel-core是babel6的基础模块,babel-loader和babel-preset-es2015用于编译ES6语法的js，babel-preset-stage-0主要是应对ES7语法标准的插件，babel-preset-react用于编译react。先看一个栗子 babel-polyfillBabel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。举例来说，ES6在Array对象上新增了Array.from方法。Babel就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。 引入代码：import 'babel-polyfill';// 或者require('babel-polyfill'); webpack打包css安装如下几个loader：$ npm install style-loader css-loader sass-loader --save-dev style-loader 将css插入到页面的style标签 css-loader 是处理css文件中的url()等 sass-loader 是将sass文件编译成css webpack-dev-server安装：$ npm install webpack-dev-server -g 启动：$ webpack-dev-server --content-base ./ –content-base ./ 参数表示将当前目录作为 server 根目录。 命令启动过后，会在 8080 端口启动一个 http 服务，通过访问 http://localhost:8080/index.html 可以访问 index.html 内容。此时修改内容，刷新页面，页面内容的改变并没有呈现出来，因为webpack-dev-server的打包结果是放在内存中的，此时可以在webpack.config.js的output中加上publicPath，现在再刷新页面就可以看见效果了！ 实时刷新1、Iframe 模式 修改访问的路径： http://localhost:8080/index.html -&gt; http://localhost:8080/webpack-dev-server/index.html 。这个时候每次修改代码，打包完成过后都会自动刷新页面。 不需要额外配置，只用修改路径 应用被嵌入了一个 iframe 内部，页面顶部可以展示打包进度信息 因为 iframe 的关系，如果应用有多个页面，无法看到当前应用的 url 信息 2、inline 模式 启动 webpack-dev-server 的时候添加 –inline 参数 需要添加 –inline 配置参数 没有顶部信息提示条，提示信息在控制台中展现 热加载webpack-dev-server 还提供了模块热加载的方式，在不刷新浏览器的条件下，应用最新的代码更新，启动 webpack-dev-server 的时候添加 –inline –hot 参数就可以体验。$ webpack-dev-server --inline --hot 也可以在webpack.config.js中配置plugins: [ // 需要手动添加 HotModuleReplacementPlugin , 命令行的方式会自动添加 new webpack.HotModuleReplacementPlugin()],devServer: &#123; hot: true, inline: true&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[表单提交问题]]></title>
      <url>http://yoursite.com/2016/05/12/form-submit/</url>
      <content type="text"><![CDATA[表单提交方式 input[type=submit] button[type=submit] input[type=image] form对象调用submit()方法 submit事件 阻止表单提交 设置提交按钮disabled属性 调用submit事件 1、调用submit方法的时候不会触发submit事件，但是与之对应的有一个重置表单方法reset，调用后会触发reset事件。2、在点击提交按钮的时候，先触发click事件，再触发submit事件3、type=image的表单元素通过表单 elements 属性是获取不到的 submit事件demo1绑定myform.onsubmit = function()&#123; return false;&#125; 这种方式直接返回false即可 demo2绑定function addListener(element, type, handler)&#123; if (!element) &#123; return; &#125; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else &#123;//for ie element.attachEvent("on" + type, handler); &#125; &#125;addListener(obj, 'submit', function()&#123; return false&#125;); 以上提交方式在ie下可以阻止表单提交，但是在ff或者chrome却不行，究其原因是addListener中的事件处理函数没有返回值，写了也白写！ The listener parameter is a EventListener object.Object EventListener：This is an ECMAScript function reference. This method has no return value. The parameter is a Event object. 解决方法：addListener(obj, 'submit', function(e)&#123; var e = e || window.event; if(e.preventDefault)&#123; e.preventDefault(); &#125;else&#123; e.returnValue = false; &#125;&#125;); 脚本处理完自己的工作后由元素处理事件，元素可以通过事件对象判断是否执行默认操作！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PS一键切图]]></title>
      <url>http://yoursite.com/2016/05/11/ps-shortCut/</url>
      <content type="text"><![CDATA[作为一名前端，明天都在做着重复的切图工作，如果方法不佳，会浪费大把的生命，下面小生介绍一个切图小技巧，提高一下工作效率！ 步骤 点击下载一键切图 载入：菜单栏—&gt;窗口—&gt;动作，按照此步骤打开动作面板，点击面板右上角（见图中红框），出现下拉菜单，选择‘载入动作’，然后将刚才下载的‘一键切图动作’载入。 选择一张psd图，选中其中一个图层，按F2，奇迹就会发生！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ESL之config配置]]></title>
      <url>http://yoursite.com/2016/05/10/esl-config/</url>
      <content type="text"><![CDATA[config默认配置var requireConf = &#123; baseUrl: './', paths: &#123;&#125;, config: &#123;&#125;, map: &#123;&#125;, packages: [], waitSeconds: 0, noRequests: &#123;&#125;, urlArgs: &#123;&#125; &#125;; 所有的配置初始化在createConfIndex函数中完成 baseUrl在整个源码中只有以下两处出现过：createConfIndex对baseUrl的处理//处理末尾有或者没有‘/’requireConf.baseUrl = requireConf.baseUrl.replace(/\/$/, '') + '/'; 对于baseUrl，末尾可以有“/”也可以没有！ 在toUrl函数中拼接模块的url// 相对路径时，附加baseUrl(url前面不能有"/") if (!/^([a-z]&#123;2,10&#125;:\/)?\//i.test(url)) &#123; url = requireConf.baseUrl + url; &#125; 在加载模块时，会把所有的要通过script标签加载define文件的url前面拼接baseUrl paths配置 require.config(&#123; baseUrl: "http://j2.58cdn.com.cn/m58/njs/", paths: &#123; test: "pkg/house" &#125; &#125;); require(['test/ershoufang_list'], function() &#123; console.log('pkg ershoufang_list callback') &#125;); createConfIndex对paths的处理pathsIndex = createKVSortedIndex(requireConf.paths);//处理结果pathsIndex = &#123; k: "test", reg: /^test(\/|$)/, //前缀匹配 v: "pkg/house"&#125; toUrl的处理// paths处理和匹配var isPathMap;// 将url中的key用pathsIndex中value替换indexRetrieve(id, pathsIndex, function(value, key) &#123; url = url.replace(key, value); isPathMap = 1;&#125;);// 如果pathsIndex没有匹配，就用packagesIndex处理urlif (!isPathMap) &#123; indexRetrieve(id, packagesIndex, function(value, key, item) &#123; url = url.replace(item.name, item.location); &#125;);&#125; 相当于在url中用paths的key作为模块id的一部分，而其value才是url真实的一部分，并且packages和paths是互斥的！ packages配置require.config(&#123; baseUrl: "http://j2.58cdn.com.cn/m58/njs/", packages: [&#123; name: "test", location: "pkg/house", main: "ershoufang_list", &#125;] &#125;); require(['test'], function() &#123; console.log('pkg ershoufang_list callback') &#125;); createConfIndex对packages的处理packagesIndex = []; each(requireConf.packages, function(packageConf) &#123; var pkg = packageConf; if (typeof packageConf === 'string') &#123; pkg = &#123; name: packageConf.split('/')[0], location: packageConf, main: 'main' &#125;; &#125; pkg.location = pkg.location || pkg.name; pkg.main = (pkg.main || 'main').replace(/\.js$/i, ''); pkg.reg = createPrefixRegexp(pkg.name); //前缀匹配name packagesIndex.push(pkg); &#125; ); packagesIndex.sort(descSorterByKOrName); packagesIndex一般会有name、location、main和reg这四个属性 在normalize中//packagesIndex中某项的name属性与moduleId相同，就将main属性拼接在moduleId之后 each(packagesIndex, function(packageConf) &#123; var name = packageConf.name; if (name === moduleId) &#123; moduleId = name + '/' + packageConf.main; return false; &#125; &#125; ); packagesIndex的name属性与moduleId匹配时，把main属性拼接上 toUrl的处理// paths处理和匹配var isPathMap;// 将url中的key用pathsIndex中value替换indexRetrieve(id, pathsIndex, function(value, key) &#123; url = url.replace(key, value); isPathMap = 1;&#125;);// 如果pathsIndex没有匹配，就用packagesIndex处理urlif (!isPathMap) &#123; indexRetrieve(id, packagesIndex, function(value, key, item) &#123; url = url.replace(item.name, item.location); &#125;);&#125; 如果匹配，就用packagesIndex的location属性替换url中的name部分 map配置require.config(&#123; baseUrl: "http://j2.58cdn.com.cn/m58/njs/", map: &#123; "pkg/house/ershoufang_list": &#123; "test": "mod/common" &#125; &#125; &#125;); require(['pkg/house/ershoufang_list'], function() &#123; console.log('pkg ershoufang_list callback') &#125;); createConfIndex中的处理mappingIdIndex = createKVSortedIndex(requireConf.map, 1); each(mappingIdIndex, function(item) &#123; item.v = createKVSortedIndex(item.v); &#125; ); normalize中的处理// mappingIdIndex=[&#123;reg1:xx,k1:xx,v1:&#123;reg2:xx,k2:xx,v2:xx&#125;&#125;]，reg1匹配baseId，reg2匹配moduleId,将moduleId中的k2用v2替换 indexRetrieve(baseId, mappingIdIndex, function(value) &#123; indexRetrieve(moduleId, value, function(mdValue, mdKey) &#123; moduleId = moduleId.replace(mdKey, mdValue); &#125; ); &#125;); map就是paths多一层，先匹配父模块的id，再匹配子模块的id，最后替换的是子模块的id urlArgs配置require.config(&#123; // ... urlArgs: 'v=2.0.0' // 指定所有模块的路径后参数&#125;);require.config(&#123; // ... urlArgs: &#123; common: '1.2.0' // 为common和common下的子模块指定路径后参数 &#125;&#125;); createConfIndex中的处理urlArgsIndex = createKVSortedIndex(requireConf.urlArgs); require.config中的处理if (newValue) &#123; if (key === 'urlArgs' &amp;&amp; typeof newValue === 'string') &#123; defaultUrlArgs = newValue; &#125; else &#123; 在urlArgs设置为字符串时，会赋值给defaultUrlArgs toUrl中的处理// 拼接查询字段，如果urlArgsIndex拼接了，defaultUrlArgs就不用拼接 var isUrlArgsAppended; indexRetrieve(id, urlArgsIndex, function(value) &#123; appendUrlArgs(value); &#125;); defaultUrlArgs &amp;&amp; appendUrlArgs(defaultUrlArgs); urlArgs主要作用是在模块的url上拼接一个查询字符串 waitSeconds配置require.config(&#123; // ... waitSeconds: 5&#125;); 指定等待的秒数。超过等待时间后，如果有模块未成功加载或初始化，将抛出 MODULE_TIMEOUT 异常错误信息。 noRequests配置require.config(&#123; baseUrl: "http://j2.58cdn.com.cn/m58/njs/", noRequests: &#123; "pkg/house/ershoufang_list": ["pkg/house/ershoufang_list"] &#125; &#125;); require(['pkg/house/ershoufang_list'], function() &#123; console.log('pkg ershoufang_list callback') &#125;); createConfIndex中的处理noRequestsIndex = createKVSortedIndex(requireConf.noRequests); each(noRequestsIndex, function(item) &#123;//[&#123;reg:xx,k:xx,v:[xx,xx]&#125;] var value = item.v; var mapIndex = &#123;&#125;; item.v = mapIndex; if (!(value instanceof Array)) &#123; value = [value]; &#125; each(value, function(meetId) &#123; //[&#123;reg:xx,k:xx,v:&#123;xx:1,xx:1&#125;&#125;] mapIndex[meetId] = 1; &#125;); &#125;); actualGlobalRequire函数中的处理each(pureModules, function(id) &#123; var meet; // noRequestsIndex = //[&#123;reg:xx,k:xx,v:&#123;xx:1,xx:1&#125;&#125;] // reg要匹配id，v值的属性还要存在一个pureModules indexRetrieve(id, noRequestsIndex, function(value) &#123; meet = value; &#125;); if (meet) &#123; if (meet['*']) &#123; noRequestModules[id] = 1; &#125; else &#123; each(pureModules, function(meetId) &#123; if (meet[meetId]) &#123; noRequestModules[id] = 1; return false; &#125; &#125;); &#125; &#125; &#125;); nativeRequire( pureModules, function() &#123; //require回调函数所在 each(normalizedIds, function(id, i) &#123; if (id == null) &#123; normalizedIds[i] = normalize(requireId[i], baseId); // 对有感叹号的id做处理 &#125; &#125;); nativeRequire(normalizedIds, callback, baseId); &#125;, baseId, noRequestModules ); native中的处理each(ids, function(id) &#123; if (!(BUILDIN_MODULE[id] || modIs(id, MODULE_DEFINED))) &#123; modAddDefinedListener(id, tryFinishRequire); //为没有达到MODULE_DEFINED的模块增加监听函数 if (!noRequests[id]) &#123; //若存在就不加载 (id.indexOf('!') &gt; 0 ? loadResource : loadModule)(id, baseId); &#125; &#125;&#125;); noRequests的作用就是拒绝加载require中引入的模块]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ESL模块处理过程]]></title>
      <url>http://yoursite.com/2016/05/10/esl-run-route/</url>
      <content type="text"><![CDATA[ESL是什么ESL是一个浏览器端、符合AMD的标准加载器，适合于现代web浏览器端应用的入口与模块管理。相比于RequireJS拥有以下优点： 体积更小 性能更高 更健壮 不支持非浏览器端使用 依赖模块用时定义 ESL模块加载详解 esl.js加载模块过程如下： 1、require引入模块的入口，调用nativeRequire，在这个函数中通过tryFinishRequire绑定require的callback，并且把tryFinishRequire作为监听函数绑在入口模块上； 2、nativeRequire通过loadModule加载入口js文件即define文件，并且通过onload绑定一个监听函数loadedListener； 3、define函数生产出模块的id、依赖模块和callback； 4、等到define文件执行完成，loadedListener会通过completePreDefine将模块数据加入到modModules中； 5、最后通过modAnalyse分析依赖模块的属性以及处理url，其中会调用modAutoInvoke（核心函数）处理最后的结果，如果依赖的模块还存在没有加载的，再次统一放入nativeRequire中，循环上面的过程！ 核心函数modAutoInvoke分析//核心函数 递归设置所有模块状态为3，递归执行所有invokeFactory function modAutoInvoke() &#123; for (var id in autoDefineModules) &#123; modUpdatePreparedState(id); //一次性设置有依赖关系的模块为状态3 modTryInvokeFactory(id); &#125; &#125; autoDefineModules数组存放着作为入口的模块； modUpdatePreparedState的作用：采用递归遍历所有模块，检测依赖的模块是否都是状态3，如果是，autoDefineModules中对应的模块状态可以设置为3，如果不是，则不能设置为3； modTryInvokeFactory的作用是在autoDefineModules中模块状态达到3时，执行InvokeFactory； //invokeFactory中的两段代码 each(module.factoryDeps, function(dep) &#123; var depId = dep.absId; if (!BUILDIN_MODULE[depId]) &#123; modTryInvokeFactory(depId); //递归执行依赖模块的invokeFactory if (!modIs(depId, MODULE_DEFINED)) &#123; //所有依赖的模块必须达到MODULE_DEFINED factoryReady = 0; return false; &#125; &#125; factoryDeps.push(depId); //达到MODULE_DEFINED状态的模块被推入factoryDeps中 &#125; ); //所有依赖的模块必须达到MODULE_DEFINED就可以执行下面的代码 if (factoryReady) &#123; try &#123; var args = modGetModulesExports( //依赖模块的输出 factoryDeps, &#123; require: module.require, exports: module.exports, module: module &#125; ); var factory = module.factory; var exports = typeof factory === 'function' ? factory.apply(global, args) : factory; if (exports != null) &#123; module.exports = exports; &#125; module.invokeFactory = null; &#125; catch (ex) &#123;&#125; modDefined(id); //设置为状态4,执行监听函数 &#125; &#125;&#125; 以上是invokeFactory中的两段代码，这个函数的作用就是输出模块的执行结果，但是在输出自身之前必须通过modTryInvokeFactory递归所有依赖的模块，这些依赖的模块也都必须输出执行结果，赋值在exports中，供父模块调用！ 核心函数modAutoInvoke调用在整个源文件中，调用modAutoInvoke主要有两处，一个是modAnalyse最后执行，在当前模块分析完毕，状态达到2时调用，另外一处是nativeRequire中！核心思想就是在每处理一个模块，都要从入口模块递归依赖的所有模块，以达到一旦所有模块准备就绪，就可以执行require的callback函数！ demo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[viewport]]></title>
      <url>http://yoursite.com/2016/05/07/viewport/</url>
      <content type="text"><![CDATA[viewport的概念layout viewport通俗的讲，移动设备上的viewport就是设备的屏幕上能用来显示我们的网页的那一块区域，在具体一点，就是浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域要大，也可能比浏览器的可视区域要小。在默认情况下，一般来讲，移动设备上的viewport都是要大于浏览器可视区域的，这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小，所以为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px或1024px（也可能是其它值，这个是由设备自己决定的），但带来的后果就是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。下图是一些设备上浏览器的默认viewport的宽度。这个layout viewport的宽度可以通过 document.documentElement.clientWidth 来获取。 visual viewport它是在不同的缩放（initial-scale）情况下浏览器可视区域的大小（需要多少css像素填充），visual viewport的宽度可以通过window.innerWidth 来获取，但在Android 2, Oprea mini 和 UC 8中无法正确获取。 ideal viewport这个viewport可以理解为最适合当前机型的viewport。不同的手机的可能拥有不同的ideal viewport,一般iphone手机都是320px，但是安卓设备就比较复杂了，有320px的，有360px的，有384px的等等，关于不同的设备ideal viewport的宽度都为多少，可以到http://viewportsizes.com去查看一下，里面收集了众多设备的理想宽度。 像素的理解物理像素(physical pixel)一个物理像素是显示器(手机屏幕)上最小的物理显示单元，在操作系统的调度下，每一个设备像素都有自己的颜色值和亮度值。 设备独立像素(density-independent pixel)设备独立像素(也叫密度无关像素)，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css像素)，然后由相关系统转换为物理像素。 设备像素比(device pixel ratio )定义了物理像素和设备独立像素的对应关系，它的值可以按如下的公式的得到： 设备像素比 = 物理像素 / 设备独立像素 // 在某一方向上，x方向或者y方向 在js中，dpr = window.devicePixelRatio 在css中，可以通过-webkit-device-pixel-ratio，-webkit-min-device-pixel-ratio和 -webkit-max-device-pixel-ratio进行媒体查询，对不同dpr的设备，做一些样式适配(这里只针对webkit内核的浏览器和webview)。 综合上面几个概念，一起举例说明下： 以iphone6为例：设备宽高为375×667，可以理解为设备独立像素(或css像素)。dpr为2，根据上面的计算公式，其物理像素就应该×2，为750×1334。在css像素大小不变的情况下，普通屏幕下，1个css像素 对应 1个物理像素(1:1)，retina屏幕下，1个css像素对应 4个物理像素(1:4)。 meta.viewport详解几个概念一般在做移动端页面时，会把这行代码复制到页面中。该meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户对其进行缩放。一般，width设置layout viewport 的宽度，为一个正整数，或字符串”width-device”；initial-scale 设置页面的初始缩放值，为一个数字，可以带小数；minimum-scale允许用户的最小缩放值，为一个数字，可以带小数；maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数；user-scalable 是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许。当然还可以设置其他的值，用逗号隔开就可以。 width和initial-scale在移动端页面中的作用（1）通过width=device-width，所有浏览器都能把当前的viewport宽度变成ideal viewport的宽度，但要注意的是，在iphone和ipad上，无论是竖屏还是横屏，宽度都是竖屏时ideal viewport的宽度。（2）initial-scale的缩放是相对于ideal viewport来进行缩放的，当对ideal viewport进行100%的缩放，也就是缩放值为1的时候，得到的就是ideal viewport（3）ideal viewport的值会取width和initial-scale两个中较大的那个值 关于initial-scale的缩放initial-scale是对页面就行缩放（个人理解就是缩放单位css像素的大小），测试如下，在meta中去掉width这一项，visual viewport得出如下数据：从上图可以看出，在屏幕宽度不变的情况下，当initial-scale变小，预示着css像素变小，导致填充整个屏幕需要的css像素就会变多。因此，我们可以得出一个公式：visual viewport宽度 = ideal viewport宽度 / 当前缩放值 关于width去掉initial-scale，测试width。当width=160时，这是因为有些元素把宽高都写死了，此时initial-scale=2，元素都变为原来的2倍，所以导致页面很挤。当width=1280时，这是因为有些元素把宽高都写死了，此时initial-scale=2，元素都变为原来的0.25倍，所以导致页面的元素很小。 结论在iphone和ipad上，无论你给viewport设的宽的是多少，如果没有指定默认的缩放值，则iphone和ipad会自动计算这个缩放值，以达到当前页面不会出现横向滚动条(或者说viewport的宽度就是屏幕的宽度)的目的。安卓设备上的initial-scale默认值好像没有方法能够得到，或者就是干脆它就没有默认值，一定要你显示的写出来这个东西才会起作用！ 利用meta.viewport对多屏适配布局retina下，border: 1px问题经常border：1px在不同手机上的宽度不一样，如下：上图中，对于一条1px宽的直线，它们在屏幕上的物理尺寸(灰色区域)的确是相同的，不同的其实是屏幕上最小的物理显示单元，即物理像素，所以对于一条直线，iphone5它能显示的最小宽度其实是图中的红线圈出来的灰色区域，用css来表示，理论上说是0.5px。所以，设计师想要的retina下border:1px;，其实就是1物理像素宽，对于css而言，可以认为是border: 0.5px;，这是retina下(dpr=2)下能显示的最小单位。 多屏适配布局移动端布局，为了适配各种大屏手机，目前最好用的方案莫过于使用相对单位rem。rem = document.documentElement.clientWidth * dpr / 10 javascript方式，通过上面的公式，计算出基准值rem，然后写入样式。 以下是淘宝的代码： (function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; docEl.style.fontSize = 20 * (clientWidth / 320) + 'px'; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(document, window); 可以看出，他们也仅仅按照手机屏幕的宽度在做适配，没有动用dpr和scale，个人认为这两个必须同时运用，页面才会在理想情况下展现！ 一般方法大概如下： var dpr, rem, scale;var docEl = document.documentElement;var fontEl = document.createElement('style');var metaEl = document.querySelector('meta[name="viewport"]');dpr = win.devicePixelRatio || 1;scale = 1 / dpr;rem = docEl.clientWidth * dpr / 10;// 设置viewport，进行缩放，达到高清效果metaEl.setAttribute('content', 'width=' + dpr * docEl.clientWidth + ',initial-scale=' + scale + ',maximum-scale=' + scale + ', minimum-scale=' + scale + ',user-scalable=no');// 设置data-dpr属性，留作的css hack之用docEl.setAttribute('data-dpr', dpr);// 动态写入样式docEl.firstElementChild.appendChild(fontEl);fontEl.innerHTML = 'html&#123;font-size:' + rem + 'px!important;&#125;';// 给js调用的，某一dpr下rem和px之间的转换函数window.rem2px = function(v) &#123; v = parseFloat(v); return v * rem;&#125;;window.px2rem: function(v) &#123; v = parseFloat(v); return v / rem;&#125;;window.dpr = dpr;window.rem = rem; 以上设置是为了保证，1个css像素占据一个物理像素。如果有一个区块，在psd文件中量出：宽高750×300px的div，那么如何转换成rem单位呢？如果scale是1，对于iphone6来说就是取一半，如果scale是0.5，量出多少是多少，换句话说就是设计稿的宽度W=docEl.clientWidth * dpr，对于不符合的设计稿，计算公式如下：我们现在写页面参考的机型一般是iphone4以上，dpr一般都是2，所以按照以上写法其实只有viewport的宽度在起作用，但是如果遇到宽度和dpr都不一样的时候，两者的倍数都会起作用，如果遇到iphone3这样的，宽度不变而dpr变化的，它上面的元素就会比iphone4要小，遇到这样的机型，如果不改变scale，样式有可能出问题！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端之webp图片]]></title>
      <url>http://yoursite.com/2016/04/27/image-to-webp/</url>
      <content type="text"><![CDATA[webp是什么？WebP格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。但WebP是一种有损压缩。相较编码JPEG文件，编码同样质量的WebP文件需要占用更多的计算资源。 目前使用情况国外的网站：Youtube、Facebook.etc国内的网站：腾讯、淘宝、美团等 webp兼容性支持chrome opera4s uc5 uc5s uc6 uc6s uc华为荣耀6 qq内置浏览器 微信 uc 自带浏览器魅族 微信 uc 自带浏览器三星（Galay S4） uc 自带浏览器 QQ浏览器红米1s（andr4.3） uc QQ浏览器-v6.4.1 自带浏览器 不支持58app-v6.5.74s safari5 safari5s safari6 safari6s safari5s qq内置浏览器6 qq内置浏览器6s qq内置浏览器QQ浏览器-v6.0QQ浏览器-v6.45微信5s微信6微信6s微信5s 高速浏览器 如何转换智图iSpartalibwebp 如何使用js检测，准备两套图片路径var kTestImages = &#123; lossy: "UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", lossless: "UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==", alpha: "UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==", animation: "UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA"&#125;;var img = new Image();img.onload = function () &#123; var result = (img.width &gt; 0) &amp;&amp; (img.height &gt; 0); callback(feature, result);&#125;;img.onerror = function () &#123; callback(feature, false);&#125;;img.src = "data:image/webp;base64," + kTestImages[feature];&#125; 使用webp.js插件将会捕捉页面中使用WebP格式的img元素，并用Flash进行替换。图像的解码及显示都在Flash中完成，因此目前版本对CSS设置的背景图片无效。当然，作为JPEG格式的替换，只有对较大的图像使用才有意义，否则过多的解码将消耗大量的资源。3、用html5中提供的picture元素选择图片格式（浏览器支持的情况不好） server-response（Accept和varry）Acceptiphone4suc无Accept请求头Safari Accept:*/*微信 Accept:*/*QQ浏览器-v6.4 Accept:*/*小米4uc：Accept:image/webp自带浏览器：Accept:image/webpchrome：Accept:image/webpQQ浏览器：Accept:image/webp并不是所有的请求头都包含images/webp 目前只有opera有 varry(client) &gt; Accept: image/jpeg, image/png, image/mif(server) &gt; Content-Type: image/mif &gt; Vary: Accept &gt; (object) 优势WebP is a new image format that provides lossless and lossy compression for images on the web. WebP lossless images are 26% smaller in size compared to PNGs. WebP lossy images are 25-34% smaller in size compared to JPEG images at equivalent SSIM index. WebP supports lossless transparency (also known as alpha channel) with just 22% additional bytes. Transparency is also supported with lossy compression and typically provides 3x smaller file sizes compared to PNG when lossy compression is acceptable for the red/green/blue color channels. 参考文献：WebP 探寻之路A new image format for the WebDeploying New Image Formats on the WebHow To Reduce Image Size With WebP Automagically让你的页面支持WebP图像]]></content>
    </entry>

    
  
  
</search>
