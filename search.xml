<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[typeof-instanceof]]></title>
      <url>http://yoursite.com/2017/03/13/typeof-instanceof/</url>
      <content type="text"><![CDATA[typeoftypeof undefined //'undefined'typeof null //'object'typeof true //'boolean'typeof 123 //'number'typeof 'abc' //'string'typeof function() &#123;&#125; //'function'typeof &#123;&#125; //'object'typeof [] //'object'typeof unknownVariable //'undefined' instanceof模拟解析过程如下：function _instanceof(A, B) &#123; var O = B.prototype;// 取B的显示原型 A = A.__proto__;// 取A的隐式原型 while (true) &#123; //Object.prototype.__proto__ === null if (A === null) return false; if (O === A)// 这里重点：当 O 严格等于 A 时，返回 true return true; A = A.__proto__; &#125;&#125; Object instanceof Object解析,执行_instanceof (Object, Object)O = Object.prototype;A = Object.__proto__ = Function.prototypeA = Function.prototype.__proto__ = Object.prototypereturn true;Function instanceof Function解析,执行_instanceof (Function, Function)O = Function.prototype;A = Function.__proto__ = Function.prototype;return true;Function instanceof Object解析,执行_instanceof (Function, Object)O = Object.prototype;A = Function.__proto__ = Function.prototype;A = Function.prototype.__proto__ = Object.prototype;return true;String instanceof String解析,执行_instanceof (String, String)O = String.prototype;A = String.__proto__ = Function.prototype;A = Function.prototype.__proto__ = Object.prototype;A = Object.prototype.__proto__ = null;return false;function Ben()&#123;&#125;Ben instanceof Ben解析,执行_instanceof (Ben, Ben)O = Ben.prototype;A = Ben.__proto__ = Function.prototype;A = Function.prototype.__proto__ = Object.prototype;A = Object.prototype.__proto__ = null;return false;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[call-apply-bind]]></title>
      <url>http://yoursite.com/2017/03/12/call-apply-bind/</url>
      <content type="text"><![CDATA[call、apply区别 func.call(obj, a, b, c) func.apply(obj, [a, b, c]) apply相比于call有何妙用呢？如下： function log()&#123; console.log.apply(console, arguments);&#125;;log(1); //1log(1,2); //1 2 log参数事先不知道会是多少个，所以用apply就可以模糊传参，当然参数至少是数组或者类数组，而如果使用call，就需要把数组或者类数组转化成单个参数，就会比较麻烦。 bindfunc.bind(obj, a, b)(c, d) bind第一次绑定上下文不会执行，还需再加一个小括号才会执行，a、b、c、d会一起作为参数传入，官方兼容实现如下： if (!Function.prototype.bind) &#123; Function.prototype.bind = function (oThis) &#123; if (typeof this !== "function") &#123; // closest thing possible to the ECMAScript 5 internal IsCallable function throw new TypeError("Function.prototype.bind - what is trying to be bound is not callable"); &#125; var aArgs = Array.prototype.slice.call(arguments, 1), fToBind = this, fNOP = function () &#123;&#125;, fBound = function () &#123; return fToBind.apply(this instanceof fNOP &amp;&amp; oThis ? this : oThis || window, aArgs.concat(Array.prototype.slice.call(arguments))); &#125;; fNOP.prototype = this.prototype; fBound.prototype = new fNOP(); return fBound; &#125;; &#125; this instanceof fNOP &amp;&amp; oThis ? this : oThis || window 解释： 如果没有new绑定上下文后的方法，那么执行的时候返回的上下文是oThis或者window 如果有new，this instanceof fNOP肯定是真，如果有参数，oThis也是真，返回this即new出来的fBound对象，此对象的原型链指向fToBind的原型链，相当于对原函数做了一次new 如果有new，this instanceof fNOP肯定是真，如果没有参数，oThis是假，fToBind内部的上下文就变成了window，如下：var f = func.bind();new f(); 经笔者在Chrome下测试，发现上面第三条有错误嫌疑，结果和第二条相同，所以可以把&amp;&amp; oThis去掉，但是笔者不清楚是版本的问题还是浏览器实现的问题！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[跨域方式]]></title>
      <url>http://yoursite.com/2017/03/12/%E8%B7%A8%E5%9F%9F/</url>
      <content type="text"><![CDATA[跨域的概念页面与页面之间和浏览器与服务器之间进行通信，如果协议、域名、端口有任何一个不同，都被当作是不同的域，此时的通信是不被浏览器同源策略所允许的。那么如何解决跨域呢？大概有如下一些常用的方法！ jsonp 首先浏览器端先定义一个执行函数：function dosomething(json)&#123; //to do something&#125; 在页面插入一个script标签，url=&#39;http://XXXX?callback=dosomething&#39;，此时就会向服务器发送这么个请求。 当服务器接收到这个请求，就会把callback当做一个key，然后得到这个key对应的value值，此处是dosomething；key也可以不是callback,开发者可以定义其他的字符串代替，当然前端要告诉后端这个key是什么！ 后端获得了value是dosomething,就会做下面的操作，就是拼接出一个参数是json的执行函数，返回给前端 dosomething+"("+json+")" 页面加载这个js代码，就会直接执行，那么就可以在dosomething这个函数体里面做自己想做的事！ document.domain主要适用于不同iframe框架之间的通信，但要注意的是，document.domain的设置是有限制的，我们只能把document.domain设置成自身或更高一级的父域，且主域必须相同！两个页面都要设置！ 不过如果你想在http://www.example.com/a.html 页面中通过ajax直接请求http://example.com/b.html 页面，即使你设置了相同的document.domain也还是不行的，所以修改document.domain的方法只适用于不同子域的框架间的交互。如果你想通过ajax的方法去与不同子域的页面交互，除了使用jsonp的方法外，还可以用一个隐藏的iframe来做一个代理。原理就是让这个iframe载入一个与你想要通过ajax获取数据的目标页面处在相同的域的页面，所以这个iframe中的页面是可以正常使用ajax去获取你要的数据的，然后就是通过我们刚刚讲得修改document.domain的方法，让我们能通过js完全控制这个iframe，这样我们就可以让iframe去发送ajax请求，然后收到的数据我们也可以获得了。 window.name+iframe 特点：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置。 比如有一个www.example.com/a.html页面,需要通过a.html页面里的js来获取另一个位于不同域上的页面www.cnblogs.com/data.html里的数据。 data.html页面里的代码很简单，就是给当前的window.name设置一个a.html页面想要得到的数据值。data.html里的代码： 在a.html页面中使用一个隐藏的iframe来充当一个中间人角色，src设为www.cnblogs.com/data.html 待data.html加载完成后，将此iframe指向www.example.com/b.html，那么b.html就可以通过windwo.name获取data.html 待b.html加载完成，那么a.html页面就可以获取data.html中的数据 window.postMessage window.postMessage(message,targetOrigin)方法是html5新引进的特性，可以使用它来向其它的window对象发送消息，无论这个window对象是属于同源或不同源，目前IE8+、FireFox、Chrome、Opera等浏览器都已经支持window.postMessage方法 调用postMessage方法的window对象是指要接收消息的那一个window对象，该方法的第一个参数message为要发送的消息，类型只能为字符串；第二个参数targetOrigin用来限定接收消息的那个window对象所在的域，如果不想限定域，可以使用通配符*。 需要接收消息的window对象，可是通过监听自身的message事件来获取传过来的消息，消息内容储存在该事件对象的data属性中window.onmessage = function(e)&#123; e = window.event || e; var data = e.data; //是传递来的message var source = e.source; //发送消息的窗口对象 var origin = e.origin; //发送消息窗口的源（协议+主机+端口号）&#125; 跨域资源共享CORS此种跨域方式就请移步峰哥的文章跨域资源共享 CORS 详解，这篇文章说的很详细！ XDomainRequest ie8+浏览器跨域请求的ajax对象 跨域请求（XDRs）匿名保护用户数据，就是说服务器不能确定谁在请求数据。为了防止泄露数据给恶意的站点，不鼓励启用XDRs请求。 跨域请求要页面和服务器之间双方同意才行。使用 XDomainRequest (XDR) 创建对象，链接到服务器，文档请求服务器时添加一个Origin 请求头代表请求源，只有当服务器设置了 Access-Control-Allow-Origin 响应头为* 或者为发送请求的url地址。var xdr; function readdata() &#123; var dRes = document.getElementById('dResponse'); dRes.innerText = xdr.responseText; alert("Content-type: " + xdr.contentType); alert("Length: " + xdr.responseText.length); &#125; function err() &#123; alert("XDR onerror"); &#125; function timeo() &#123; alert("XDR ontimeout"); &#125; function loadd() &#123; alert("XDR onload"); alert("Got: " + xdr.responseText); &#125; function progres() &#123; alert("XDR onprogress"); alert("Got: " + xdr.responseText); &#125; function stopdata() &#123; xdr.abort(); &#125; function mytest() &#123; var url = document.getElementById('tbURL'); var timeout = document.getElementById('tbTO'); if (window.XDomainRequest) &#123; xdr = new XDomainRequest(); if (xdr) &#123; xdr.onerror = err; xdr.ontimeout = timeo; xdr.onprogress = progres; xdr.onload = loadd; xdr.timeout = tbTO.value; xdr.open("get", tbURL.value); xdr.send(); &#125; else &#123; alert("Failed to create"); &#125; &#125; else &#123; alert("XDR doesn't exist"); &#125; &#125; 其他跨域方式还有flash、在服务器上设置代理页面等跨域方式，不过笔者不会flash，也没尝试过服务器设置代理页面这种方式！以上几种方法可以满足大部分的业务需求了！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[addEventListener和attachEvent 区别]]></title>
      <url>http://yoursite.com/2017/03/05/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%861/</url>
      <content type="text"><![CDATA[1、addEventListenertarget.addEventListener(type, listener, useCapture); 兼容性：ie9+及现代浏览器 type：字符串，事件名称，不含“on”，比如“click”、“mouseover”、“keydown”等 useCapture：是否使用捕捉，一般用false（冒泡） 删除方式：removeEventListener(event,function,capture/bubble) 执行顺序：定义最早的最先执行 作用域：this指向绑定的元素 FF下event对象有target,但没有srcElement属性,chrome下都有 event有currentTarget event有stopPropagation，stopImmediatePropagation cancelBubble属性只能用于阻止冒泡，无法阻止捕获阶段。该值可读写，默认值是false。当设置为true时，cancelBubble可以取消事件冒泡 event支持preventDefault 第二个参数可以是对象，事件会自动在传入对象中寻找handleEvent方法（ie9+支持） 2、attachEventtarget.attachEvent(type, listener); 兼容性：ie5到ie10 type：字符串，事件名称，含“on”，比如“onclick”、“onmouseover”、“onkeydown”等 useCapture：无 删除方式：detachEvent(event,function) 执行顺序：定义最早的最后执行 作用域：this指向window ie8-下event对象有srcElement,但没有target属性 ie8-下event没有currentTarget ie8-下event没有stopPropagation，stopImmediatePropagation，ie也支持cancelBubble ie8-下event没有cancelable(只读) ie8-下event对象没有eventPhase ie8-下event不支持preventDefault，但是支持returnValue=false ie8-下event不支持defaultPrevented(只读)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[理解中的MVC、MVP和MVVM]]></title>
      <url>http://yoursite.com/2016/12/16/MVC/</url>
      <content type="text"><![CDATA[一直理解不了MVC的架构模式，不过最近在看发布的业务代码，仿佛有了新的突破，所以写篇博客记录一下 MVP&lt;select id="selAnimal"&gt; &lt;option value="cat"&gt;cat&lt;/option&gt; &lt;option value="fish"&gt;fish&lt;/option&gt; &lt;option value="bird"&gt;bird&lt;/option&gt; &lt;/select&gt; &lt;p id="whatDoesThisAnimalDo"&gt;&lt;/p&gt; &lt;script type="text/javascript"&gt; // whatDoesAnimalDo 就是一个controllervar whatDoesAnimalDo = &#123; // 选择视图 start: function() &#123; this.view.start(); &#125;, // 将用户的操作映射到模型的更新上 set: function(animalName) &#123; this.model.setAnimal(animalName); &#125;,&#125;;// whatDoesAnimalDo的数据modelwhatDoesAnimalDo.model = &#123; // animal的数据 animalDictionary: &#123; cat: "meows", fish: "swims", bird: "flies" &#125;, // 当前的animal，也就是这个application的状态 currentAnimal: null, // 数据模型负责业务逻辑和数据存储 setAnimal: function(animalName) &#123; this.currentAnimal = this.animalDictionary[animalName] ? animalName : null; this.onchange(); &#125;, // 并且通知视图更新显示 onchange: function() &#123; whatDoesAnimalDo.view.update(); &#125;, // 还需要响应视图对当前状态的查询 getAnimalAction: function() &#123; return this.currentAnimal ? this.currentAnimal + " " + this.animalDictionary[this.currentAnimal] : "wuff?"; &#125;&#125;;// whatDoesAnimalDo的视图whatDoesAnimalDo.view = &#123; // 用户输入触发onchange事件 start: function() &#123; document.getElementById('selAnimal').onchange = this.onchange; &#125;, // 该事件将用户请求发送给控制器 onchange: function() &#123; whatDoesAnimalDo.set(document.getElementById('selAnimal').value); &#125;, // 视图更新显示的方法，其中视图会向model查询当前的状态，并将其显示给用户 update: function() &#123; document.getElementById('whatDoesThisAnimalDo').innerHTML = whatDoesAnimalDo.model.getAnimalAction(); &#125;&#125;;whatDoesAnimalDo.start();&lt;/script&gt; 上面是一段实现MVC的小清新的代码，从中可以看出，UI绑定的事件在View层做，通过View层给Controller做一个指示，Controller调用指定的Model去做数据上操作，操作完成，Model就是调用View层刷新页面！过程如下：Controller可以作为一个中继器，为View层命令分发到对应的Model层，比如发布，有很多UI组件，UI组件即创建了视图也加入了业务逻辑，可以看成是View和Model的结合体。那么当组件与组件间有交互时，可以通过Controller中转，相当于一个Controller对应于很多个View和Model。 MVPMVP模式斩断了View层和Model层的联系，完全通过Presenter层做桥梁：渲染View的功能也放在了Presenter层中。 MVVMMVVM和MVP有点类似，如图： ViewModel是整个架构的核心，连接着View和Model，View做了很多声明式绑定（按照一定规则），Model就是要操作的数据。ViewModel根据声明的规则把Model的数据映射到View层，同时对View层的操作和自身数据做监听。 参照大神的MVVM框架设计，代码的核心就是对每个需要监控的属性，都会生成set与get的访问控制器。无论是绑定事件还是用户在控制台修改，只要修改了被监控的属性，就会在访问控制器中做处理，把处理后的数据反映到View层并且更新Model层，即这就是所谓数据驱动！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Chrome-debug]]></title>
      <url>http://yoursite.com/2016/12/14/Chrome-debug/</url>
      <content type="text"><![CDATA[面试经常有人问你，你熟悉chrome调试工具吗？真的熟悉了吗？那么小生来总结一下，有些操作确实不常用！ Sources 我们知道js打断点，可是还有两种断点不常用 DOM Breakpoints Subtree Modifications：对dom节点的child做添加，删除或者修改，就会触发 Attributes Modifications：对dom节点的属性做添加，删除或者修改，就会触发 Node Removal：对dom节点进行删除，就会触发 XHR Breakpoints 当右侧的url和请求的url匹配时就会出现断点！ Call Stack调用栈当断点执行到某一程序块处停下来后，右侧调试区的 Call Stack 会显示当前断点所处的方法调用栈，从上到下由最新调用处依次往下排列，Call Stack 列表的下方是Scope Variables列表可以查看此时局部变量和全局变量的值。图中可以看出，我们最先走了toggleTab这个方法，然后走到了一个更新对象的方法上，当前调用在哪里，箭头会帮你指向哪里，同时我们可以点击，调用栈列表上的任意一处，即可回头再去看看代码但是若你想从新从某个调用方法出执行，可以右键Restart Frame， 断点就会跳到此处开头重新执行，Scope 中的变量值也会依据代码从新更改，这样就可以回退来从新调试，错过的调试也可以回过头来反复查看 Network1、控制Network的外观和功能 红色1号是Network是否记录网络请求的开关（这些按钮一试便知，不具体操作） 红色2号可以清楚网络日志 红色3号可以捕捉屏幕，打开按钮，重新刷新页面，会获取一张张页面加载过程的图像，点击图像，log也会相应变化 View改变overview和log记录表的外观 Preserve log是否保存上一次的网络日志 Disable cache缓存是否可用，打上勾网络请求就不会走本地缓存 offline这部分可以模拟无网、2G、3G等网速的请求 2、Filters 控制Requests Table具体显示哪些内容 输入框可以输入过滤条件，可以写正则表达式 hide data urls 可以隐藏base64请求 后面的按钮可以只显示对应的网络日志 3、Summary 显示总的请求数、数据传输量、加载时间信息DOMContentLoaded和load这两个事件会高亮显示 DOMContentLoaded事件会在页面上DOM完全加载并解析完毕之后触发，不会等待CSS、图片、子框架加载完成。load事件会在页面上所有DOM、CSS、JS、图片完全加载完毕之后触发。 DOMContentLoaded事件在Overview上用一条蓝色竖线标记，并且在Summary以蓝色文字显示确切的时间。 load事件同样会在Overview和Requests Table上用一条红色竖线标记，在Summary也会以红色文字显示确切的时间。 4、Requests Table 按资源获取的前后顺序显示所有获取到的资源信息，点击资源名可以查看该资源的详细信息Initiator 标记请求是由哪个对象或进程发起的（请求源） Parser： 请求由Chrome的HTML解析器时发起的。 Redirect：请求是由HTTP页面重定向发起的。 Script：请求是由Script脚本发起的。 Other：请求是由其他进程发起的，比如用户点击一个链接跳转到另一个页面或者在地址栏输入URL地址。 5、Timeline瀑布流 Queuing 排队的时间花费。可能由于该请求被渲染引擎认为是优先级比较低的资源（图片）、服务器不可用、超过浏览器的并发请求的最大连接数（Chrome的最大并发连接数为6） Stalled 从建立HTTP连接请求发出到请求能够被发出送出去(真正传输数据)之间的时间花费。包含用于处理代理的时间，如果有已经建立好的连接，这个时间还包括等待已建立连接被复用的时间。 Proxy Negotiation 与代理服务器连接的时间花费。(包含于Stalled) DNS Lookup 执行DNS查询的时间。网页上每一个新的域名都要经过一个DNS查询。第二次访问浏览器有缓存的话，则这个时间为0。 Initial Connection建立连接的时间花费，包含了TCP握手及重试时间。 SSL 完成SSL握手的时间花费，包含于Initial Connection中。 Request sent 发起请求的时间 Waiting (Time to first byte (TTFB)) 是最初的网络请求被发起到从服务器接收到第一个字节这段时间，它包含Request sent时间 Content Download 获取Response响应数据的时间花费。 TTFB这个部分的时间花费如果超过200ms，则应该考虑对网络进行性能优化了，可以参见网络性能优化方案及里面的相关参考文档。 通过按住Shift并且把光标移到资源名称上，可以查看该资源是由哪个对象或进程发起的（请求源）和对该资源的请求过程中引发了哪些资源（依赖资源）。在该资源的上方第一个标记为绿色的资源就是该资源的发起者（请求源），有可能会有第二个标记为绿色的资源是该资源的发起者的发起者，以此类推 Timeline 说实话在所有的部分中，timeline最难，当初刚接触前端时，师傅就让我总结devtools，当时就卡在此处，两年后的我再来看一下。 该面板主要包括4大块：1、Controls 开始、停止和配置什么信息将要被获取2、Overview 网页性能的概要3、Flame Chart CPU堆栈轨迹可视化表4、Details 当选择一个指定的事件后，会显示这个事件的更多信息；当没有选择事件时，会显示指定的时间帧信息 Flame Chart里面的虚竖线含义：蓝色标记DOMContentLoaded事件；绿色标记第一次的绘制时间点；红色代表load事件。 其中第2块Overview显示了网页性能相关的概要信息，可以通过鼠标或者区域边界上的灰色滑块来拖出一个指定区域范围，Flame Chart会跟着局部放大显示指定区域内的详情信息。 可以通过键盘上的W,S来放大和缩小指定区域，通过A,D来向左或向右移动指定区域。 Overview部分包括三个图标： FPS 每秒的帧数(Frames Per Second)，绿色柱状条越高，则每秒帧数越高，上方的红色柱状是一个长帧，在这个过程中可能发生jank CPU使用情况 这里的面积图标记着消耗CPU资源的各类事件 NET 各种颜色的柱状条分别显示一种资源。柱状条越长，代表获取这个资源的时间越长 CPU面积图中各颜色的含义：蓝色代表HTML文件；黄色代表脚本文件；紫色代表样式文件；绿色代表媒体文件；灰色代表其它杂项文件。NET图表柱状条两种颜色的含义：较亮的部分表示等待时间（当资源被请求时，直到第一个字节被下载的时间)；较暗的部分表示传输时间(在第一个和最后一个字节被下载之间的时间)。 支持两种网页录制操作：①录制网页加载，②录制网页交互。为了便于分析，录制的时间不宜太长、还要避免不必要的交互操作、并禁用浏览器的缓存和插件。 当你在Flame Chart中选择一个事件，Detail面板就会展示此事件额外的信息。Summary会展现所有的事件信息，另外的部分仅仅对某些事件有效，详细请看Timeline event reference 在录制之前点击Controls中的Screenshots复选框，可以在录制过程中捕获截屏，鼠标在Overview上从左向右移动则可以看到录制的动画。 在录制之前点击Controls中的JS Profile复选框，可以在时间轴中捕获JavaScript的堆栈信息(会产生一定的性能消耗)，并且在Flame Chart(火焰图)中会显示所有被调用的JavaScript函数信息。 在录制之前点击Controls中的Paint复选框，可以获取绘制事件的更多细节信息（注意这会产生很多的性能消耗）。如果要深入了解网页渲染方面的信息，可以点击DevTools右上角的菜单，在More tools里面选中Rendering settings，这里面包含了如下设置项： Paint Flashing 高亮显示网页中需要被重绘的部分。 Layer Borders 显示Layer边界。 FPS Meter 每一秒的帧细节，帧速率的分布信息和GPU的内存使用情况。 Scrolling Performance Issues 分析鼠标滚动时的性能问题，会显示使屏幕滚动变慢的区域。 Emulate CSS Media 仿真CSS媒体类型，查看不同的设备上CSS样式效果，可能的媒体类型选项有print、screen。 可以通过在DevTools上按Cmd+F(Mac)调出查询框，来查看指定时间区域范围内的指定类型的事件，点击Cmd+G(Mac)或者Cmd+Shift+G(Mac)可以按事件发生的顺序来查询。图中查询到了4个红色标记着的Parse HTML事件，点击Cmd+G焦点会在这4个事件移动。 在Overview和Flame Chart上面右键，可以保存和打开记录 Profiles概述当前使用的Chrome最新版为 54.0.2840.71，这个版本的Profiles面板比之前提供的功能更多也更强大，下面是该面板所包含的功能点： Record JavaScript CPU Profile 用于分析网页上的JavaScript函数在执行过程中的CPU消耗信息。 Take Heap Snapshot 创建堆快照用来显示网页上的JS对象和相关的DOM节点的内存分布情况。 Record Allocation Timeline 从整个Heap角度记录内存的分配信息的时间轴信息，利用这个可以实现隔离内存泄漏问题。 Record Allocation Profile 从JS函数角度记录内存的分配信息。 Record JavaScript CPU Profile简介通过选择Record JavaScript CPU Profile，然后点击Start，结合你所要分析的具体场景，你可以重新加载网页，或者在网页上进行交互，甚至什么都不操作。最后点击Stop，完成记录操作。有三种不同的视图可供选择： Chart 按时间先后顺序显示的火焰图。 Heavy(Bottom Up) （自底向上）根据对性能的消耗影响列出所有的函数，并可以查看该函数的调用路径。 Tree(Top Down) (自顶向下) 从调用栈的顶端（最初调用的位置）开始，显示调用结构的总体的树状图情况 我们以Chart视图为例分析一下JS的执行的性能情况： 该视图会以时间顺序展示CPU的性能情况，视图主要分成两块： Overview 整个录制结果的鸟瞰图（概览），柱形条的高度对应了调用堆栈的深度，也就是说柱形条高度越高，调用堆栈的深度越深。 Call Stacks 在录制过程中被调用的函数的深入分析视图（调用堆栈），横轴表示时间，纵轴表示调用栈，自上而下的表示函数的调用情况。也就是说上面的函数调用在它下面的函数。视图中的函数颜色不同于其它的面板，这里面的函数颜色标记是随机显示的。然而相同的函数调用颜色标记是相同的。其中纵轴表示的函数调用堆栈高度仅仅函数的调用嵌套层次比较深，不表示其重要性很高，但是横轴上一个很宽的柱形条则意味着函数的调用需要一个很长的时间去完成，那么你就考虑去做一些优化操作。将鼠标移到Call Stacks中的函数上可以显示函数的名称和时间相关的数据，会提供如下信息： Name 函数名称 Self time 函数的本次调用运行的时间，仅仅包含该函数本身的运行时间，不包含它所调用的子函数的时间。 Total time 函数的本次调用运行的总时间，包含它所调用的子函数的运行时间。 URL 函数定义在文件中所在的位置，其格式为file.js:100，表示函数在file.js文件中的第100行。 Aggregated self time 在这次的录制过程中函数调用运行的总时间，不包含它所调用的子函数的时间。 Aggregated total time 在这次的录制过程中所有的函数调用运行的总时间，包含它所调用的子函数的时间。 Not optimized 如果优化器检测到该函数有潜在的优化空间，那么该函数会被列在这里。 Take Heap Snapshot简介通过创建堆快照可以查看创建快照时网页上的JS对象和DOM节点的内存分布情况。利用该工具你可以创建JS的堆快照、内存分析图、对比堆快照以及定位内存泄漏问题。选中Take Heap Snapshot,点击Take Snapshot按钮即可获取快照，在每一次获取快照前都会自动执行垃圾回收操作。快照最初会存储在渲染进程的内存之中，当我们点击创建快照按钮来查看时才会被传输到DevTools中，当快照被加载到DevTools里面并经过解析之后，在快照标题下方的文字显示的数字就是可访问到的JS对象总的大小。堆快照提供了不同的视角来进行查看： Summary 该视图按照构造函数进行分组，用它可以捕获对象和它们使用的内存情况，对于跟踪定位DOM节点的内存泄漏特别有用。 Comparison 对比两个快照的差别，用它可以对比某个操作前后的内存快照。分析操作前后的内存释放情况以及它的引用计数，便于你确认内存是否存在泄漏以及造成的原因。 Containment 该视图可以探测堆的具体内容，它提供了一个更适合的视图来查看对象结构，有助于分析对象的引用情况，使用它可以分析闭包和进行更深层次的对象分析。 Statistics 统计视图。 Summary视图该视图会显示所有的对象信息，点击其中的一个对象进行展开可查看更详细的实例信息。鼠标移动到某个对象上会显示该对象实例的详情信息。图中的各列的具体含义如下： Constructor 显示所有的构造函数，点击每一个构造函数可以查看由该构造函数创建的所有对象。 Distance 显示通过最短的节点路径到根节点的距离。 Objects Count 显示对象的个数和百分比。 Shallow size 显示由特定的构造函数创建的所有对象的本身的内存总数。 Retained size 显示由该对象及其它所引用的对象的总的内存总数。 Shallow size和Retained size的区别？Shallow size是对象本身占用内存的大小，不包含它所引用的对象。Retained size是该对象本身的Shallow size，加上能从该对象直接或者间接访问到对象的Shallow size之和。也就是说Retained size是该对象被GC之后所能回收到内存的总和。 在展开构造函数，则会列出该函数相关的所有对象实例，可以查看该对象的Shallow size和Retained size，在@符号后面的数字是该对象的唯一标识ID。其中黄色的对象表示它被某个JS所引用，而红色的对象表示由黄色背景色引用被分离开的节点。这些构造函数都代表什么含义呢？ (global property) 全局对象（比如window）和通过它引用的对象之间的中间对象，如果一个对象是由Person构造函数生成并被全局对象所引用，那么它们的引用路径关系就像这样[global] &gt; (global property) &gt; Person。这跟常规的对象之间直接引用相比，采用中间对象主要是考虑性能的原因。全局对象的改变是很频繁的，而非全局变量的属性访问最优化方案对全局变量是不适用的。 (roots) 它们可以是由引擎自己的目标创建的一些引用，这个引擎可以缓存引用的对象，但所有的这些引用都是弱引用，它们不会阻止引用对象被回收。 (closure) 一些函数闭包中的一组对象的引用。 (array, string, number, regexp) 一系属性引用了数组(Array),字符串(String),数字(Number)或正则表达式的对象类型。 HTMLDivElement, HTMLAnchorElement, DocumentFragment等 你的代码中对元素(elements)的引用或者指定的document对象的引用。 Comparison视图通过比较多个快照之间的差异来找出内存泄露的对象，为了验证某个程序的操作不会引起内存泄露（通常会执行一个操作后再执行一个对应的相反操作，比如打开一个文档后再关闭它，应该是没有产生内存泄露问题的），你可以执行如下步骤： 在执行一个操作之前拍一个快照。 执行一个操作，通过你认为可能会引起内存泄露的一次页面交互操作。 执行一个相反的操作。 拍第二个快照，切换到Comparison视图，并与第一个快照进行对比。 切换到Comparison视图之后，就可以看到两个不同的快照之间的差别。 Containment视图该视图本质上就是应用程序的对象结构的“鸟瞰图”，允许你去深入分析函数的闭包，了解应用程序底层的内存使用情况。这个视图提供了多个入口： DOMWindow objects DOMWindow对象，即JS代码全局对象。 Native objects 浏览器原生对象，比如DOM节点，CSS规则。 闭包小建议: 在快照的分析中命名函数的闭包相比匿名函数的闭包更容易区分。Google上提供的例子和图如下： function createLargeClosure() &#123; var largeStr = new Array(1000000).join('x'); var lC = function() &#123; // 匿名函数 return largeStr; &#125;; return lC;&#125; function createLargeClosure() &#123; var largeStr = new Array(1000000).join('x'); var lC = function lC() &#123; // 命名函数 return largeStr; &#125;; return lC;&#125; Statistics视图该视图是堆快照的总的分布统计情况，这个直接上图就可以了： 内存泄露示例:DOM内存泄露可能比你想象的要大，考虑一下下面的例子-什么时候#tree节点被释放掉？var select = document.querySelector;var treeRef = select("#tree");var leafRef = select("#leaf");var body = select("body");body.removeChild(treeRef);//由于treeRef #tree不能被释放treeRef = null;//由于leafRef的间接引用 #tree还是不能被释放leafRef = null;//现在没有被引用，#tree这个时候才可以被释放了 #leaf节点保持着对它的父节点(parentNode)的引用，这样一直递归引用了#tree节点，所以只有当leafRef被设置成null后，#tree下面的整个树节点才有可能被垃圾回收器回收。 Record Allocation Timeline简介该工具是可以帮助你追踪JS堆里面的内存泄漏的另一大利器。选中Record Allocation Timeline按钮，点击Start按钮之后，执行你认为可能会引起内存泄漏的操作，操作之后点击左上角的停止按钮即可。你可以在蓝色竖线上通过缩放来过滤构造器窗格来仅仅显示在指定的时间帧内的被分配的对象。 录制过程中，在时间线上会出现一些蓝色竖条，这些蓝色竖条代表一个新的内存分配，这个新的内存分配都可以会有潜在的内存泄露问题。通过展开对象并点击它的值则可以在Object窗格中查看更多新分配的对象细节。 Record Allocation Profile简介从JS函数角度记录并查看内存的分配信息。点击Start按钮，执行你想要去深入分析的页面操作，当你完成你的操作后点击Stop按钮。然后会显示一个按JS函数进行内存分配的分解图，默认的视图是Heavy (Bottom Up)，该视图会把最消耗内存的函数显示在最顶端。下图是切换到Chart视图时具体的界面，点击任意函数跳转到Sources面板可以查看具体的函数信息。 Application面板简介该面板主要是记录网站加载的所有资源信息，包括存储数据（Local Storage、Session Storage、IndexedDB、Web SQL、Cookies）、缓存数据、字体、图片、脚本、样式表等。 Local Storage 如果你在开发过程中使用了local storage来存储键值对(KVPs)，那么你就可以通过Local Storage窗格来检查、新增、修改、删除这个键值对。 Application Cache 你可以使用Application Cache窗格去查看通过Application Cache API创建的资源。 Frames 将页面上的资源按frame类别进行组织显示。 Frames窗格在上图中可以查看到顶级的top是一个主文档，在top下面是主文档的Fonts、Images、Scripts、Stylesheets等资源。最后一个就是主文件自身。在资源上右击后在弹出菜单选择Reveal in Network Panel，就会跳转到Network面板并定位到该资源的位置。你也可以在Sources面板里面按frame类别来查看资源信息。 Security面板简介通过该面板你可以去调试当前网页的安全和认证等问题并确保您已经在你的网站上正确地实现HTTPS。 HTTPS（Hyper Text Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。 它是一个URI scheme（抽象标识符体系），句法类同http:体系。用于安全的HTTP数据传输。https:URL表明它使用了HTTP，但HTTPS存在不同于HTTP的默认端口及一个加密/身份验证层（在HTTP与TCP之间）。HTTPS和HTTP的区别主要为以下四点：① https协议需要到CA申请证书，一般免费证书很少，需要交费。② http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。③ http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。④ http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。 如果网页是安全的，则会显示这样一条消息：This page is secure (valid HTTPS).。通过点击View certificate可以查看main origin的服务器证书信息。点击左侧可以查看指定源的连接和证书详情。如果网页是不安全的，则会显示：This page is not secure.。该面板可以区分两种类型的不安全的页面： 如果被请求的页面通过HTTP提供服务，那么这个主源就会被标记为不安全。 如果被请求的页面是通过HTTPS获取的，但这个页面接着通过HTTP继续从其他来源检索内容，那么这个页面仍然被标记为不安全。这就是所谓的混合内容页面,混合内容页面只是部分受到保护,因为HTTP内容(非加密的内容)可以被嗅探者入侵,容易受到中间人攻击。 点击左侧则提供一个跳转到Network面板视图的链接信息。 中间人攻击(Man-in-the-Middle Attack,”MITM攻击”)是一种“间接”的入侵攻击，这种攻击模式是通过各种技术手段将受入侵者控制的一台计算机虚拟放置在网络连接中的两台通信计算机之间，这台计算机就称为“中间人”。 Audits面板简介对当前网页进行网络利用情况、网页性能方面的诊断，并给出一些优化建议。比如列出所有没有用到的CSS文件等。选中Network Utilization、Web Page Performance，点击Run按钮，将会对当前页面进行网络利用率和页面的性能优化作出诊断，并给出相应的优化建议。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[react-redux详解]]></title>
      <url>http://yoursite.com/2016/12/06/react-redux%E8%AF%A6%E8%A7%A3/</url>
      <content type="text"><![CDATA[connect 拥有三个参数mapStateToProps， mapDispatchToProps， mergeProps， options mapStateToProps 外部的数据即state对象转换为UI组件的参数 mapStateToProps是一个函数，执行后应该返回一个对象，这个对象会与组件的props合并。 mapStateToProps会订阅Store，每当state更新的时候，就会自动执行，重新计算UI组件的参数，从而触发UI组件的重新渲染。 mapStateToProps的第一个参数总是state对象，还可以使用第二个参数ownProps，代表UI组件的props对象。 connect方法可以省略mapStateToProps参数，那样的话，UI组件就不会订阅Store，就是说Store的更新不会引起UI组件的更新。 mapDispatchToProps 用户发出的动作变为Action对象，从UI组件传出去 如果作为函数会得到dispatch和ownProps两个参数，mapDispatchToProps执行后应该返回一个对象，这个对象会与组件的props合并。 如果mapDispatchToProps是一个对象，会先用bindActionCreators处理，之后合并到props中。 如果你省略这个mapDispatchToProps参数，默认情况下，dispatch会注入到你的组件props中。 mergeProps 拥有三个参数stateProps，dispatchProps，ownProps 如果指定了这个参数，mapStateToProps与mapDispatchToProps的执行结果和组件自身的props将传入到这个回调函数中。该回调函数返回的对象将作为props传递到被包装的组件中。 options pure = true: 如果为true，connector将执行shouldComponentUpdate并且浅对比mergeProps的结果，避免不必要的更新，前提是当前组件是一个“纯”组件，它不依赖于任何的输入或state而只依赖于props和Redux store的state。默认值为true。 withRef = false: 如果为true，connector会保存一个对被包装组件实例的引用，该引用通过 getWrappedInstance()方法获得。默认值为false。 组件Provider在根组件外面包了一层，这样一来，App的所有子组件就默认都可以拿到state了。它的原理是React组件的context属性，请看源码:class Provider extends Component &#123; getChildContext() &#123; return &#123; store: this.props.store &#125;; &#125; render() &#123; return this.props.children; &#125;&#125;Provider.childContextTypes = &#123; store: React.PropTypes.object&#125; 组件可以获取store如下：const &#123; store &#125; = this.context;this.unsubscribe = store.subscribe(() =&gt;&#123; //todo something&#125;);组件名.contextTypes = &#123;//必须加，否则context为空 store: React.PropTypes.object&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redux中间件]]></title>
      <url>http://yoursite.com/2016/12/05/redux%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      <content type="text"><![CDATA[redux-thunkreturn function (next) &#123; return function (action) &#123; if (typeof action === 'function') &#123; return action(dispatch, getState, extraArgument); &#125; return next(action); &#125;;&#125;; 加了一个对action是函数的特殊处理！ redux-logger打印各种信息]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redux详解]]></title>
      <url>http://yoursite.com/2016/12/05/redux/</url>
      <content type="text"><![CDATA[createStore这个函数有三个参数分别是reducer（function），preloadedState和enhancer(可选，function)，如果enhancer存在，那么就会走下面的逻辑：return enhancer(createStore)(reducer, preloadedState); 一旦使用中间件就会使用上面的函数，store就会在这个函数中生成！如果preloadedState是函数，enhancer是undefined，两者的值会被调换！enhancer可以看做是一种自定义的处理方式！最后返回dispatch、subscribe、getState和replaceReducer这四个函数，state和Listener都存在于createStore内部，作为闭包的一个引用！ subscribe绑定监听事件，把所有的事件函数都存放于nextListeners中，并且返回一个解绑事件的函数。 dispatchaction必须是一个对象，且type不能是undefined，执行时会把当前的state和action作为参数传入reducer中，生成新的state,此时也会执行nextListeners收集到的事件函数！注意：dispatch会在createStore初始化时执行一次！ getState获取当前的state replaceReducer初始化了createStore之后，提供一次更换reducer的机会。 bindActionCreatorsbindActionCreator处理单个actionCreator,此时actionCreator必须是函数！function bindActionCreator(actionCreator, dispatch) &#123; return function () &#123; return dispatch(actionCreator.apply(undefined, arguments)); &#125;;&#125; bindActionCreators也有这两个参数actionCreators和dispatch，一般返回一个触发dispatch的对象，此处直接看代码吧！if (typeof actionCreators === 'function') &#123; return bindActionCreator(actionCreators, dispatch);&#125;var keys = Object.keys(actionCreators);var boundActionCreators = &#123;&#125;;for (var i = 0; i &lt; keys.length; i++) &#123; var key = keys[i]; var actionCreator = actionCreators[key]; if (typeof actionCreator === 'function') &#123; boundActionCreators[key] = bindActionCreator(actionCreator, dispatch); &#125;&#125; compose1、不传参数，返回一个函数，此函数特点是直接返回一个传入的参数2、传入一个参数，直接返回这个参数3、传入不少于两个的参数，参数在函数内部会转化为一个数组，此函数会返回另外一个函数：return function () &#123; return rest.reduceRight(function (composed, f) &#123; return f(composed); &#125;, last.apply(undefined, arguments));&#125; 此函数可以当做一种数据流使用，要求compose传入的参数都是函数，那么上面这个函数的参数传入compose最后一个函数参数中，执行的结果再传入compose倒数第二个函数参数中，执行的结果再传入倒数第三个…以此类推，最后获得结果！ applyMiddlewareapplyMiddleware参数是传入的一些中间件，函数内部嵌套了两层函数用于生成store，同时也生成了一个对象：var middlewareAPI = &#123; getState: store.getState, dispatch: function dispatch(action) &#123; return _dispatch(action); &#125;&#125;; 这个对象会作为每个中间件的参数，使每个中间件都拥有store的getState和dispatch，执行后重新生成一个数组chain，chain会作为参数传入compose中，compose最后一个参数的参数是store.dispatch，最后返回一个结果_dispatch，用这个_dispatch替换store的dispatch! 重点：在初始化时，compose是从后向前执行，后一个中间件成为上一个中间件的next，但是在执行时是从前向后，当action满足第一个中间件的要求时就执行，不满足要求就把action传给next，next就是第二个中间件，以此类推。 注意：中间件一般是只修改dispatch！ combineReducers参数是一个对象reducers，会把其中值是函数的k-v对提取出来，重新生成一个对象finalReducers，处理过程直接看代码：var hasChanged = false;var nextState = &#123;&#125;;for (var i = 0; i &lt; finalReducerKeys.length; i++) &#123; var key = finalReducerKeys[i]; var reducer = finalReducers[key]; var previousStateForKey = state[key]; var nextStateForKey = reducer(previousStateForKey, action); nextState[key] = nextStateForKey; hasChanged = hasChanged || nextStateForKey !== previousStateForKey;&#125;return hasChanged ? nextState : state; 一旦nextStateForKey发生变化，就会返回新的state！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Promise实现逻辑]]></title>
      <url>http://yoursite.com/2016/11/27/Promise-logic/</url>
      <content type="text"><![CDATA[我们都知道promise可以很好的解决异步嵌套的问题，使代码更有可读性，但是一直没去研究promise的实现逻辑，最近看了一下es6-promise源码，那么下面简单介绍一下实现思想！ PromisePromise处理流程如下：一般的用法都会new一个promise对象：new Promise(function(resolve,reject)&#123; if(ok)&#123; resolve(value) &#125;else&#123; reject(reason) &#125;&#125;) Promise构造函数只有一个参数，类型为function，而此函数有两个参数也是函数类型即resolve和reject，他们两个是源码中定义的。拒绝时的状态为reject就不说了，resolve是成功时的处理函数，他会根据value进行处理 value是普通的值，他就会挂在到Promise对象的_result属性上 value是Promise对象，那么他就会把value的_result值赋值给外层的Promise对象的_result属性 value是对象且带有then函数属性，那么value就会被当做一个类似Promise的对象，运行此对象then的结果赋值给Promise对象的_result属性上 挂在Promise对象的_result属性上的值是为了传入后续的then函数中 ThenThen处理流程如下：Then有两个函数参数，使用哪一个完全依据上个Promise运行的状态。Then并不是在主线程开始运行的，在源码中专门有一个数组用于收集Then的处理。 每个Then的处理都会单独new一个新的Promise对象 第一个Then会传入数组，并启动异步执行开关 其余的Then处理会挂载到上一个Promise对象的属性上 通过遍历，当一个Then处理完成，下一个Then的处理和上一个Then处理的值就会存入数组中并且开始遍历执行，直到处理完所有的Then 在处理Then过程中value也会按照Promise方式处理 Promise.allall的处理思想和以上一致，唯一的区别是会遍历传入的数组，对每一个进行处理，在处理完全后，把值传入Then中，只不过此时的value是数组罢了 polyfill其作用是检测当前环境存不存在Promise，如果不存在就会引入源码中的Promise。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[next主题vendors报错404]]></title>
      <url>http://yoursite.com/2016/11/14/nextThemeProblemRepair/</url>
      <content type="text"><![CDATA[本地预览没问题，deploy后主页显示大面积空白最近小伙伴上传博客，发现主页显示大面积空白，打开控制台后发现vendors目录下面的js各种404，但是在github上文件是存在的，究其原因可能是GitHub Pages过滤掉了source/vendors目录的访问。 解决办法首先修改source/vendors为source/lib，然后修改_config.yml，将_internal:vendors修改为_internal:lib然后修改next底下所有引用source/vendors路径为source/lib。这些地方可以通过文件查找找出来。主要集中在这几个文件中。1. Hexo\themes\next.bowerrc 2. Hexo\themes\next.gitignore 3. Hexo\themes\next.javascript_ignore 4. Hexo\themes\next\bower.json 。修改完毕后，刷新重新g一遍就ok啦。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一个基于自身业务的前端简单生产工具]]></title>
      <url>http://yoursite.com/2016/11/13/gulp-develop-tool/</url>
      <content type="text"><![CDATA[背景目前网上有众多的构建工具，比如webpack、gulp、grunt还有fis等等，除了grunt，小生都有尝试过。先前本司一众大神推广过fis，进行过很多期讲座培训，由于公司的小白比较多，显然效果不太好，原因如下： 很多人仓促去听讲座，根本没看文档，所以听的云里雾里 fis相对比较笨重，有一定的学习成本，配置眼花缭乱 最最主要的是需求，习惯于用各种小工具搞定生产中的环节，还不容易出问题，而且效率还不错，fis要是出问题了，可能要调试半天，对于小白来说很头疼 大神们陶醉于技术的钻研，却忽略了小白们的接收能力，所有的讲座都有一个特点，就是太泛，无法深入每个细节点。大神们所有的配置都是一路畅通，但是到了小白这里各种报错，大神们认为小白应该自己看，那小白们很有可能就不看了！ 那么作者选择gulp作为构建化工具有以下几点原因： gulp文档很少，语法简单，对于我们小白来说，或多或少都会点，不见得会写，至少都能看得懂 gulp很轻巧，开源插件众多，小白们瞜一眼gulp文件，基本就知道各种task是干什么的，加以配置注释，那么自己配置应该就没什么问题了，再熟悉一点自己都可以去拓展 配置gulpfile.js创建目录搬砖首先要有文件夹，所以这里就按照小生的业务来建立文件夹目录，如下： html src css js img dist css js img mock tool doc html文件夹存放html文件，src为开发目录，包括css、js和img，因为这三者都需要经过处理，所以处理后会放入dist目录； mock是模拟数据存放的目录，一般开发，fe需要后端提供一些接口，但是往往因为开发速度不一样，rd不能及时提供，所以fe可以起一个服务，把模拟数据放在此处； tool可以存放自己的一些小工具用于其他的开发功能 doc存放需求文档等文档类的文件//创建开发目录gulp.task('g-init', function() &#123; var dirs = [dirPaths.html, dirPaths.css.src, dirPaths.js.src, dirPaths.doc, dirPaths.img.src, dirPaths.tool]; dirs.forEach(dir =&gt; &#123; mkdirp.sync(dir); &#125;)&#125;); 创建目录采用了mkdirp这个插件，路径都写在了dirs这个数组内，运行命令：gulp g-init 就可以完成以上目录结构的创建，task的名字可以自己随意起！ 处理css//处理sass文件gulp.task('g-css', function() &#123; return gulp.src(dirPaths.css.src + '/**/*.scss') .pipe(sourcemaps.init())//生成map .pipe(sass(&#123;//编译sass文件 outputStyle: 'compressed'//压缩 &#125;).on('error', sass.logError)) .pipe(autoprefixer())//添加前缀 .pipe(sourcemaps.write()) .pipe(rename(&#123;&#125;))//重命名 .pipe(gulp.dest(dirPaths.css.dist));&#125;); 看见以上代码的注释就应该知道他们是做什么的，也有一些人可能没有使用sass，那么只要自己稍微改动一下应该就没问题了 处理img//处理图片gulp.task('g-image', function() &#123; return gulp.src(dirPaths.img.src + '/**/*') .pipe(imagemin())//压缩 .pipe(gulp.dest(dirPaths.img.dist))&#125;); 这个命令只是对图片做了压缩，采用了gulp-imagemin插件，效果还行，如果不满意压缩效果，自己可以再试试其他的插件 处理整个style//处理css和imggulp.task('g-style', ['g-css', 'g-image'], function() &#123; gulp.src(dirPaths.css.dist + '/**/*.css') .pipe(spriter(spriteConfig))&#125;); 我这里把css和img都归为style，这个任务的功能就是生成和替换雪碧图，前提是先运行g-css和g-image，在把处理好的css和img文件放入dist目录下，再对他们做雪碧图的处理。spriter是我自己改装的插件gulp-cross-spriter的引用，具体功能和配置都有很详细的说明，可以点进去凑凑。多说一句，此插件readme全文都是中文，主要是为方便自己书写，也方便同胞查阅，如果要说我英语不好，我也承认，我确实对英文文档的某些语句理解挠头，不过对于英语过六级，经过研究生生涯洗礼的我来说搞一篇英文的说明文档，问题应该不大。 处理js//处理js文件gulp.task('g-js', function() &#123; gulp.src(dirPaths.js.src + '/**/*.js') .pipe(jshint())//语法检查 .pipe(jshint.reporter(stylish))//控制台报错输出的样式 .pipe(uglify()) //压缩，有一定的语法检测能力，如果语法错的太离谱，这里可能会报错 .pipe(gulp.dest(dirPaths.js.dist));&#125;); 这里对js做了语法检查和压缩，当前目录需要配置.jshintrc文件，具体相关配置请查阅文档 实时刷新gulp自带的监听功能单一，这里借助gulp-connect起一个本地的服务，可以做到html文件的试试刷新（仅仅html文件）//启动服务器gulp.task('g-connect', function() &#123; connect.server(&#123; root: serverConfig.root, //设置根目录 livereload: serverConfig.livereload, //启动实施监控 port: serverConfig.port, //设置端口 name: serverConfig.name //设置服务器名字 &#125;);&#125;);//重新加载gulp.task('g-reload', function() &#123; gulp.src(dirPaths.devPath + '/**/*.*') .pipe(connect.reload())&#125;)//监听gulp.task('g-watch', function() &#123; //watch 只能监听现存的文件对于新建文件 无法监听 gulp.watch(dirPaths.html + '/**/*.html', ['g-reload']); gulp.watch(dirPaths.js.src + '/**/*.js', ['g-reload', 'g-js']); gulp.watch(dirPaths.css.src + '/**/*.scss', ['g-reload', 'g-style']);&#125;); 那么本地服务配合watch监听，就可以在代码保存后试试刷新页面，但是监听只能监听存在的文件，对于后来新建的文件必须重新启动才行！ 默认taskgulp.task('default', ['g-connect', 'g-watch', 'g-openbrowser']); 这样只要一个gulp命令就可以建立本地服务，启动监听，并且帮你打开页面！ 综述其实开发就两条命令：gulp g-init gulp 一个是建立文件夹，一个是监听！这里有个完整的栗子，可以凑凑，我把配置都放在了一个文件里面，因为代码量并不是很多，我只想让开发者拷贝更少的文件，如果想要把配置都放在另外的文件下，也是莫问题滴！我这个目录下写了很多gulp插件的栗子，方便小白查阅！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack.plugin]]></title>
      <url>http://yoursite.com/2016/10/18/webpack-plugin/</url>
      <content type="text"><![CDATA[bell-on-bundler-error-pluginbell-on-bundler-error-plugin会通知您在打包构建过程中的错误function BellOnBundlerErrorPlugin () &#123; &#125;BellOnBundlerErrorPlugin.prototype.apply = function(compiler) &#123; if (typeof(process) !== 'undefined')&#123; compiler.plugin('done', function(stats) &#123; if (stats.hasErrors()) process.stderr.write('\x07') &#125;) compiler.plugin('failed', function(err) &#123; process.stderr.write('\x07') &#125;) &#125;&#125;module.exports = BellOnBundlerErrorPlugin CommonsChunkPluginWebpack中将打包后的文件都称之为“Chunk”。这个插件可以将多个打包后的资源中的公共部分打包成单独的文件。智能提取公共部分来方便多页面之间进行复用!先看一个简单的例子，运行一下，从下图可知，公共部分已经被独立出来，在html必须先被加载！提取的公共部分的common，还可以再和其他文件继续提取common，来看一个稍微复杂的例子,在index.html中改变js的引用文件，就可以看见效果！ page5.html: commons.js, ap1.js page4.html: commons.js, ap2.js page3.html: p3.js page2.html: commons.js, admin-commons.js, p1.js page1.html: commons.js, admin-commons.js, p2.js extract-text-webpack-plugin独立出css样式，单独打包CSS，通过link引入样式而不是放在style标签内 ExtractTextPlugin.extract([notExtractLoader], loader, [options]) noExtractLoader可选参数，未提取的css会被这个loader处理。loader列表，将资源转换为导出的css module，必选ExtractTextPlugin.extract会在这个loader列表前插入一个loader，并且最后会执行loader列表所返回的module,本人尝试这个插件，无论同一个入口中引入多少css文件，都被打包成一个css，不同的入口会单独打包一个，看一个例子，在这个例子中还增加了压缩js的功能。 webpack.DefinePlugin可以为js定义变量，这个变量是webpack自动生成插入到我们的代码中的new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV:JSON.stringify(env) &#125;, __DEV__:dev&#125;) DefinePlugin中可以传入一个对象，对象的key会被定义在我们的代码中，对应的value，就是key在代码中对应的值，值得注意的是字符串需要JSON.stringify包裹，否则这个值在代码中会生成一个变量，而不是字符串，导致代码报错，看个例子！ UglifyJsPluginnew webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false//去掉压缩过程中的提示 &#125;, beautify: true,//是否格式化 mangle: &#123; except: ['$super', '$', 'exports']//可以指定哪些变量name不混淆， &#125;, output: &#123; comments: false//是否保留注释,默认为false &#125;&#125;) 上面一些小的功能小生都加了注释，但是是否混淆小生没有找到开关! HotModuleReplacementPluginHot Module Replacement（HMR）也是webpack里很有用的一个插件，它允许你在修改组件代码后，自动刷新实时预览修改后的效果。请看详情 OccurenceOrderPlugin为组件分配ID，通过这个插件webpack可以分析和优先考虑使用最多的模块，并为它们分配最小的ID NoErrorsPlugin允许错误不打断程序]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack.learning]]></title>
      <url>http://yoursite.com/2016/10/17/webpack-learning/</url>
      <content type="text"><![CDATA[安装Node作为前端，没用过Node，只能说是个十足的菜鸟！ 全局安装webpack$ npm install webpack -g 运行例子进入文件，首先运行 npm install，安装所需要的依赖，然后可以打开example1.webpack文件夹，运行下面的命令：$ webpack src/index.js dist/index.js 之后打开index.html就可以看见运行效果！ 生成配置文件webpack.config.js查看第二个例子,进入文件，只要运行如下命令即可，$ webpack 此时webpack就会自动运行这个配置文件,如果想配置多个config文件，用如下命令：$ webpack --config webpack.config.prod.js 编译React安装一下插件$ npm install babel-loader babel-core babel-preset-es2015 babel-preset-stage-0 babel-preset-react babel-polyfill --save-dev$ npm install react react-dom --save babel-core是babel6的基础模块,babel-loader和babel-preset-es2015用于编译ES6语法的js，babel-preset-stage-0主要是应对ES7语法标准的插件，babel-preset-react用于编译react。先看一个栗子 babel-polyfillBabel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。举例来说，ES6在Array对象上新增了Array.from方法。Babel就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。 引入代码：import 'babel-polyfill';// 或者require('babel-polyfill'); webpack打包css安装如下几个loader：$ npm install style-loader css-loader sass-loader --save-dev style-loader 将css插入到页面的style标签 css-loader 是处理css文件中的url()等 sass-loader 是将sass文件编译成css webpack-dev-server安装：$ npm install webpack-dev-server -g 启动：$ webpack-dev-server --content-base ./ –content-base ./ 参数表示将当前目录作为 server 根目录。 命令启动过后，会在 8080 端口启动一个 http 服务，通过访问 http://localhost:8080/index.html 可以访问 index.html 内容。此时修改内容，刷新页面，页面内容的改变并没有呈现出来，因为webpack-dev-server的打包结果是放在内存中的，此时可以在webpack.config.js的output中加上publicPath，现在再刷新页面就可以看见效果了！ 实时刷新1、Iframe 模式 修改访问的路径： http://localhost:8080/index.html -&gt; http://localhost:8080/webpack-dev-server/index.html 。这个时候每次修改代码，打包完成过后都会自动刷新页面。 不需要额外配置，只用修改路径 应用被嵌入了一个 iframe 内部，页面顶部可以展示打包进度信息 因为 iframe 的关系，如果应用有多个页面，无法看到当前应用的 url 信息 2、inline 模式 启动 webpack-dev-server 的时候添加 –inline 参数 需要添加 –inline 配置参数 没有顶部信息提示条，提示信息在控制台中展现 热加载webpack-dev-server 还提供了模块热加载的方式，在不刷新浏览器的条件下，应用最新的代码更新，启动 webpack-dev-server 的时候添加 –inline –hot 参数就可以体验。$ webpack-dev-server --inline --hot 也可以在webpack.config.js中配置plugins: [ // 需要手动添加 HotModuleReplacementPlugin , 命令行的方式会自动添加 new webpack.HotModuleReplacementPlugin()],devServer: &#123; hot: true, inline: true&#125; 还可以利用express在本地起一个服务，利用webpack-dev-middleware和webpack-hot-middleware配合使用，请看配置详情和分析 webpack-dev-server选项 contentBase：默认webpack-dev-server会为根文件夹提供本地服务器，如果想为另外一个目录下的文件提供本地服务器，应该在这里设置其所在目录 port：设置默认监听端口，如果省略，默认为”8080“ inline：设置为true，当源文件改变时会自动刷新页面 colors：设置为true，使终端输出的文件为彩色的 historyApiFallback：在开发单页应用时非常有用，它依赖于HTML5 history API，如果设置为true，所有的跳转将指向index.html hot：热更新 devtool选项 source-map：在一个单独的文件中产生一个完整且功能完全的文件。这个文件具有最好的source map，但是它会减慢打包文件的构建速度； cheap-module-source-map：在一个单独的文件中生成一个不带列映射的map，不带列映射提高项目构建速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便； eval-source-map：使用eval打包源文件模块，在同一个文件中生成干净的完整的source map。这个选项可以在不影响构建速度的前提下生成完整的sourcemap，但是对打包后输出的JS文件的执行具有性能和安全的隐患。不过在开发阶段这是一个非常好的选项，但是在生产阶段一定不要用这个选项； cheap-module-eval-source-map：这是在打包文件时最快的生成source map的方法，生成的Source Map 会和打包后的JavaScript文件同行显示，没有列映射，和eval-source-map选项具有相似的缺点；]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[表单提交问题]]></title>
      <url>http://yoursite.com/2016/05/12/form-submit/</url>
      <content type="text"><![CDATA[表单提交方式 input[type=submit] button[type=submit] input[type=image] form对象调用submit()方法 submit事件 阻止表单提交 设置提交按钮disabled属性 调用submit事件 1、调用submit方法的时候不会触发submit事件，但是与之对应的有一个重置表单方法reset，调用后会触发reset事件。2、在点击提交按钮的时候，先触发click事件，再触发submit事件3、type=image的表单元素通过表单 elements 属性是获取不到的 submit事件demo1绑定myform.onsubmit = function()&#123; return false;&#125; 这种方式直接返回false即可 demo2绑定function addListener(element, type, handler)&#123; if (!element) &#123; return; &#125; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else &#123;//for ie element.attachEvent("on" + type, handler); &#125; &#125;addListener(obj, 'submit', function()&#123; return false&#125;); 以上提交方式在ie下可以阻止表单提交，但是在ff或者chrome却不行，究其原因是addListener中的事件处理函数没有返回值，写了也白写！ The listener parameter is a EventListener object.Object EventListener：This is an ECMAScript function reference. This method has no return value. The parameter is a Event object. 解决方法：addListener(obj, 'submit', function(e)&#123; var e = e || window.event; if(e.preventDefault)&#123; e.preventDefault(); &#125;else&#123; e.returnValue = false; &#125;&#125;); 脚本处理完自己的工作后由元素处理事件，元素可以通过事件对象判断是否执行默认操作！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PS一键切图]]></title>
      <url>http://yoursite.com/2016/05/11/ps-shortCut/</url>
      <content type="text"><![CDATA[作为一名前端，明天都在做着重复的切图工作，如果方法不佳，会浪费大把的生命，下面小生介绍一个切图小技巧，提高一下工作效率！ 步骤 点击下载一键切图 载入：菜单栏—&gt;窗口—&gt;动作，按照此步骤打开动作面板，点击面板右上角（见图中红框），出现下拉菜单，选择‘载入动作’，然后将刚才下载的‘一键切图动作’载入。 选择一张psd图，选中其中一个图层，按F2，奇迹就会发生！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ESL之config配置]]></title>
      <url>http://yoursite.com/2016/05/10/esl-config/</url>
      <content type="text"><![CDATA[config默认配置var requireConf = &#123; baseUrl: './', paths: &#123;&#125;, config: &#123;&#125;, map: &#123;&#125;, packages: [], waitSeconds: 0, noRequests: &#123;&#125;, urlArgs: &#123;&#125; &#125;; 所有的配置初始化在createConfIndex函数中完成 baseUrl在整个源码中只有以下两处出现过：createConfIndex对baseUrl的处理//处理末尾有或者没有‘/’requireConf.baseUrl = requireConf.baseUrl.replace(/\/$/, '') + '/'; 对于baseUrl，末尾可以有“/”也可以没有！ 在toUrl函数中拼接模块的url// 相对路径时，附加baseUrl(url前面不能有"/") if (!/^([a-z]&#123;2,10&#125;:\/)?\//i.test(url)) &#123; url = requireConf.baseUrl + url; &#125; 在加载模块时，会把所有的要通过script标签加载define文件的url前面拼接baseUrl paths配置 require.config(&#123; baseUrl: "http://j2.58cdn.com.cn/m58/njs/", paths: &#123; test: "pkg/house" &#125; &#125;); require(['test/ershoufang_list'], function() &#123; console.log('pkg ershoufang_list callback') &#125;); createConfIndex对paths的处理pathsIndex = createKVSortedIndex(requireConf.paths);//处理结果pathsIndex = &#123; k: "test", reg: /^test(\/|$)/, //前缀匹配 v: "pkg/house"&#125; toUrl的处理// paths处理和匹配var isPathMap;// 将url中的key用pathsIndex中value替换indexRetrieve(id, pathsIndex, function(value, key) &#123; url = url.replace(key, value); isPathMap = 1;&#125;);// 如果pathsIndex没有匹配，就用packagesIndex处理urlif (!isPathMap) &#123; indexRetrieve(id, packagesIndex, function(value, key, item) &#123; url = url.replace(item.name, item.location); &#125;);&#125; 相当于在url中用paths的key作为模块id的一部分，而其value才是url真实的一部分，并且packages和paths是互斥的！ packages配置require.config(&#123; baseUrl: "http://j2.58cdn.com.cn/m58/njs/", packages: [&#123; name: "test", location: "pkg/house", main: "ershoufang_list", &#125;] &#125;); require(['test'], function() &#123; console.log('pkg ershoufang_list callback') &#125;); createConfIndex对packages的处理packagesIndex = []; each(requireConf.packages, function(packageConf) &#123; var pkg = packageConf; if (typeof packageConf === 'string') &#123; pkg = &#123; name: packageConf.split('/')[0], location: packageConf, main: 'main' &#125;; &#125; pkg.location = pkg.location || pkg.name; pkg.main = (pkg.main || 'main').replace(/\.js$/i, ''); pkg.reg = createPrefixRegexp(pkg.name); //前缀匹配name packagesIndex.push(pkg); &#125; ); packagesIndex.sort(descSorterByKOrName); packagesIndex一般会有name、location、main和reg这四个属性 在normalize中//packagesIndex中某项的name属性与moduleId相同，就将main属性拼接在moduleId之后 each(packagesIndex, function(packageConf) &#123; var name = packageConf.name; if (name === moduleId) &#123; moduleId = name + '/' + packageConf.main; return false; &#125; &#125; ); packagesIndex的name属性与moduleId匹配时，把main属性拼接上 toUrl的处理// paths处理和匹配var isPathMap;// 将url中的key用pathsIndex中value替换indexRetrieve(id, pathsIndex, function(value, key) &#123; url = url.replace(key, value); isPathMap = 1;&#125;);// 如果pathsIndex没有匹配，就用packagesIndex处理urlif (!isPathMap) &#123; indexRetrieve(id, packagesIndex, function(value, key, item) &#123; url = url.replace(item.name, item.location); &#125;);&#125; 如果匹配，就用packagesIndex的location属性替换url中的name部分 map配置require.config(&#123; baseUrl: "http://j2.58cdn.com.cn/m58/njs/", map: &#123; "pkg/house/ershoufang_list": &#123; "test": "mod/common" &#125; &#125; &#125;); require(['pkg/house/ershoufang_list'], function() &#123; console.log('pkg ershoufang_list callback') &#125;); createConfIndex中的处理mappingIdIndex = createKVSortedIndex(requireConf.map, 1); each(mappingIdIndex, function(item) &#123; item.v = createKVSortedIndex(item.v); &#125; ); normalize中的处理// mappingIdIndex=[&#123;reg1:xx,k1:xx,v1:&#123;reg2:xx,k2:xx,v2:xx&#125;&#125;]，reg1匹配baseId，reg2匹配moduleId,将moduleId中的k2用v2替换 indexRetrieve(baseId, mappingIdIndex, function(value) &#123; indexRetrieve(moduleId, value, function(mdValue, mdKey) &#123; moduleId = moduleId.replace(mdKey, mdValue); &#125; ); &#125;); map就是paths多一层，先匹配父模块的id，再匹配子模块的id，最后替换的是子模块的id urlArgs配置require.config(&#123; // ... urlArgs: 'v=2.0.0' // 指定所有模块的路径后参数&#125;);require.config(&#123; // ... urlArgs: &#123; common: '1.2.0' // 为common和common下的子模块指定路径后参数 &#125;&#125;); createConfIndex中的处理urlArgsIndex = createKVSortedIndex(requireConf.urlArgs); require.config中的处理if (newValue) &#123; if (key === 'urlArgs' &amp;&amp; typeof newValue === 'string') &#123; defaultUrlArgs = newValue; &#125; else &#123; 在urlArgs设置为字符串时，会赋值给defaultUrlArgs toUrl中的处理// 拼接查询字段，如果urlArgsIndex拼接了，defaultUrlArgs就不用拼接 var isUrlArgsAppended; indexRetrieve(id, urlArgsIndex, function(value) &#123; appendUrlArgs(value); &#125;); defaultUrlArgs &amp;&amp; appendUrlArgs(defaultUrlArgs); urlArgs主要作用是在模块的url上拼接一个查询字符串 waitSeconds配置require.config(&#123; // ... waitSeconds: 5&#125;); 指定等待的秒数。超过等待时间后，如果有模块未成功加载或初始化，将抛出 MODULE_TIMEOUT 异常错误信息。 noRequests配置require.config(&#123; baseUrl: "http://j2.58cdn.com.cn/m58/njs/", noRequests: &#123; "pkg/house/ershoufang_list": ["pkg/house/ershoufang_list"] &#125; &#125;); require(['pkg/house/ershoufang_list'], function() &#123; console.log('pkg ershoufang_list callback') &#125;); createConfIndex中的处理noRequestsIndex = createKVSortedIndex(requireConf.noRequests); each(noRequestsIndex, function(item) &#123;//[&#123;reg:xx,k:xx,v:[xx,xx]&#125;] var value = item.v; var mapIndex = &#123;&#125;; item.v = mapIndex; if (!(value instanceof Array)) &#123; value = [value]; &#125; each(value, function(meetId) &#123; //[&#123;reg:xx,k:xx,v:&#123;xx:1,xx:1&#125;&#125;] mapIndex[meetId] = 1; &#125;); &#125;); actualGlobalRequire函数中的处理each(pureModules, function(id) &#123; var meet; // noRequestsIndex = //[&#123;reg:xx,k:xx,v:&#123;xx:1,xx:1&#125;&#125;] // reg要匹配id，v值的属性还要存在一个pureModules indexRetrieve(id, noRequestsIndex, function(value) &#123; meet = value; &#125;); if (meet) &#123; if (meet['*']) &#123; noRequestModules[id] = 1; &#125; else &#123; each(pureModules, function(meetId) &#123; if (meet[meetId]) &#123; noRequestModules[id] = 1; return false; &#125; &#125;); &#125; &#125; &#125;); nativeRequire( pureModules, function() &#123; //require回调函数所在 each(normalizedIds, function(id, i) &#123; if (id == null) &#123; normalizedIds[i] = normalize(requireId[i], baseId); // 对有感叹号的id做处理 &#125; &#125;); nativeRequire(normalizedIds, callback, baseId); &#125;, baseId, noRequestModules ); native中的处理each(ids, function(id) &#123; if (!(BUILDIN_MODULE[id] || modIs(id, MODULE_DEFINED))) &#123; modAddDefinedListener(id, tryFinishRequire); //为没有达到MODULE_DEFINED的模块增加监听函数 if (!noRequests[id]) &#123; //若存在就不加载 (id.indexOf('!') &gt; 0 ? loadResource : loadModule)(id, baseId); &#125; &#125;&#125;); noRequests的作用就是拒绝加载require中引入的模块]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ESL模块处理过程]]></title>
      <url>http://yoursite.com/2016/05/10/esl-run-route/</url>
      <content type="text"><![CDATA[ESL是什么ESL是一个浏览器端、符合AMD的标准加载器，适合于现代web浏览器端应用的入口与模块管理。相比于RequireJS拥有以下优点： 体积更小 性能更高 更健壮 不支持非浏览器端使用 依赖模块用时定义 ESL模块加载详解 esl.js加载模块过程如下： 1、require引入模块的入口，调用nativeRequire，在这个函数中通过tryFinishRequire绑定require的callback，并且把tryFinishRequire作为监听函数绑在入口模块上； 2、nativeRequire通过loadModule加载入口js文件即define文件，并且通过onload绑定一个监听函数loadedListener； 3、define函数生产出模块的id、依赖模块和callback； 4、等到define文件执行完成，loadedListener会通过completePreDefine将模块数据加入到modModules中； 5、最后通过modAnalyse分析依赖模块的属性以及处理url，其中会调用modAutoInvoke（核心函数）处理最后的结果，如果依赖的模块还存在没有加载的，再次统一放入nativeRequire中，循环上面的过程！ 核心函数modAutoInvoke分析//核心函数 递归设置所有模块状态为3，递归执行所有invokeFactory function modAutoInvoke() &#123; for (var id in autoDefineModules) &#123; modUpdatePreparedState(id); //一次性设置有依赖关系的模块为状态3 modTryInvokeFactory(id); &#125; &#125; autoDefineModules数组存放着作为入口的模块； modUpdatePreparedState的作用：采用递归遍历所有模块，检测依赖的模块是否都是状态3，如果是，autoDefineModules中对应的模块状态可以设置为3，如果不是，则不能设置为3； modTryInvokeFactory的作用是在autoDefineModules中模块状态达到3时，执行InvokeFactory； //invokeFactory中的两段代码 each(module.factoryDeps, function(dep) &#123; var depId = dep.absId; if (!BUILDIN_MODULE[depId]) &#123; modTryInvokeFactory(depId); //递归执行依赖模块的invokeFactory if (!modIs(depId, MODULE_DEFINED)) &#123; //所有依赖的模块必须达到MODULE_DEFINED factoryReady = 0; return false; &#125; &#125; factoryDeps.push(depId); //达到MODULE_DEFINED状态的模块被推入factoryDeps中 &#125; ); //所有依赖的模块必须达到MODULE_DEFINED就可以执行下面的代码 if (factoryReady) &#123; try &#123; var args = modGetModulesExports( //依赖模块的输出 factoryDeps, &#123; require: module.require, exports: module.exports, module: module &#125; ); var factory = module.factory; var exports = typeof factory === 'function' ? factory.apply(global, args) : factory; if (exports != null) &#123; module.exports = exports; &#125; module.invokeFactory = null; &#125; catch (ex) &#123;&#125; modDefined(id); //设置为状态4,执行监听函数 &#125; &#125;&#125; 以上是invokeFactory中的两段代码，这个函数的作用就是输出模块的执行结果，但是在输出自身之前必须通过modTryInvokeFactory递归所有依赖的模块，这些依赖的模块也都必须输出执行结果，赋值在exports中，供父模块调用！ 核心函数modAutoInvoke调用在整个源文件中，调用modAutoInvoke主要有两处，一个是modAnalyse最后执行，在当前模块分析完毕，状态达到2时调用，另外一处是nativeRequire中！核心思想就是在每处理一个模块，都要从入口模块递归依赖的所有模块，以达到一旦所有模块准备就绪，就可以执行require的callback函数！ demo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[viewport]]></title>
      <url>http://yoursite.com/2016/05/07/viewport/</url>
      <content type="text"><![CDATA[viewport的概念layout viewport通俗的讲，移动设备上的viewport就是设备的屏幕上能用来显示我们的网页的那一块区域，在具体一点，就是浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域要大，也可能比浏览器的可视区域要小。在默认情况下，一般来讲，移动设备上的viewport都是要大于浏览器可视区域的，这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小，所以为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px或1024px（也可能是其它值，这个是由设备自己决定的），但带来的后果就是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。下图是一些设备上浏览器的默认viewport的宽度。这个layout viewport的宽度可以通过 document.documentElement.clientWidth 来获取。 visual viewport它是在不同的缩放（initial-scale）情况下浏览器可视区域的大小（需要多少css像素填充），visual viewport的宽度可以通过window.innerWidth 来获取，但在Android 2, Oprea mini 和 UC 8中无法正确获取。 ideal viewport这个viewport可以理解为最适合当前机型的viewport。不同的手机的可能拥有不同的ideal viewport,一般iphone手机都是320px，但是安卓设备就比较复杂了，有320px的，有360px的，有384px的等等，关于不同的设备ideal viewport的宽度都为多少，可以到http://viewportsizes.com去查看一下，里面收集了众多设备的理想宽度。 像素的理解物理像素(physical pixel)一个物理像素是显示器(手机屏幕)上最小的物理显示单元，在操作系统的调度下，每一个设备像素都有自己的颜色值和亮度值。 设备独立像素(density-independent pixel)设备独立像素(也叫密度无关像素)，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css像素)，然后由相关系统转换为物理像素。 设备像素比(device pixel ratio )定义了物理像素和设备独立像素的对应关系，它的值可以按如下的公式的得到： 设备像素比 = 物理像素 / 设备独立像素 // 在某一方向上，x方向或者y方向 在js中，dpr = window.devicePixelRatio 在css中，可以通过-webkit-device-pixel-ratio，-webkit-min-device-pixel-ratio和 -webkit-max-device-pixel-ratio进行媒体查询，对不同dpr的设备，做一些样式适配(这里只针对webkit内核的浏览器和webview)。 综合上面几个概念，一起举例说明下： 以iphone6为例：设备宽高为375×667，可以理解为设备独立像素(或css像素)。dpr为2，根据上面的计算公式，其物理像素就应该×2，为750×1334。在css像素大小不变的情况下，普通屏幕下，1个css像素 对应 1个物理像素(1:1)，retina屏幕下，1个css像素对应 4个物理像素(1:4)。 meta.viewport详解几个概念一般在做移动端页面时，会把这行代码复制到页面中。该meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户对其进行缩放。一般，width设置layout viewport 的宽度，为一个正整数，或字符串”width-device”；initial-scale 设置页面的初始缩放值，为一个数字，可以带小数；minimum-scale允许用户的最小缩放值，为一个数字，可以带小数；maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数；user-scalable 是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许。当然还可以设置其他的值，用逗号隔开就可以。 width和initial-scale在移动端页面中的作用（1）通过width=device-width，所有浏览器都能把当前的viewport宽度变成ideal viewport的宽度，但要注意的是，在iphone和ipad上，无论是竖屏还是横屏，宽度都是竖屏时ideal viewport的宽度。（2）initial-scale的缩放是相对于ideal viewport来进行缩放的，当对ideal viewport进行100%的缩放，也就是缩放值为1的时候，得到的就是ideal viewport（3）ideal viewport的值会取width和initial-scale两个中较大的那个值 关于initial-scale的缩放initial-scale是对页面就行缩放（个人理解就是缩放单位css像素的大小），测试如下，在meta中去掉width这一项，visual viewport得出如下数据：从上图可以看出，在屏幕宽度不变的情况下，当initial-scale变小，预示着css像素变小，导致填充整个屏幕需要的css像素就会变多。因此，我们可以得出一个公式：visual viewport宽度 = ideal viewport宽度 / 当前缩放值 关于width去掉initial-scale，测试width。当width=160时，这是因为有些元素把宽高都写死了，此时initial-scale=2，元素都变为原来的2倍，所以导致页面很挤。当width=1280时，这是因为有些元素把宽高都写死了，此时initial-scale=2，元素都变为原来的0.25倍，所以导致页面的元素很小。 结论在iphone和ipad上，无论你给viewport设的宽的是多少，如果没有指定默认的缩放值，则iphone和ipad会自动计算这个缩放值，以达到当前页面不会出现横向滚动条(或者说viewport的宽度就是屏幕的宽度)的目的。安卓设备上的initial-scale默认值好像没有方法能够得到，或者就是干脆它就没有默认值，一定要你显示的写出来这个东西才会起作用！ 利用meta.viewport对多屏适配布局retina下，border: 1px问题经常border：1px在不同手机上的宽度不一样，如下：上图中，对于一条1px宽的直线，它们在屏幕上的物理尺寸(灰色区域)的确是相同的，不同的其实是屏幕上最小的物理显示单元，即物理像素，所以对于一条直线，iphone5它能显示的最小宽度其实是图中的红线圈出来的灰色区域，用css来表示，理论上说是0.5px。所以，设计师想要的retina下border:1px;，其实就是1物理像素宽，对于css而言，可以认为是border: 0.5px;，这是retina下(dpr=2)下能显示的最小单位。 多屏适配布局移动端布局，为了适配各种大屏手机，目前最好用的方案莫过于使用相对单位rem。rem = document.documentElement.clientWidth * dpr / 10 javascript方式，通过上面的公式，计算出基准值rem，然后写入样式。 以下是淘宝的代码： (function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; docEl.style.fontSize = 20 * (clientWidth / 320) + 'px'; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(document, window); 可以看出，他们也仅仅按照手机屏幕的宽度在做适配，没有动用dpr和scale，个人认为这两个必须同时运用，页面才会在理想情况下展现！ 一般方法大概如下： var dpr, rem, scale;var docEl = document.documentElement;var fontEl = document.createElement('style');var metaEl = document.querySelector('meta[name="viewport"]');dpr = win.devicePixelRatio || 1;scale = 1 / dpr;rem = docEl.clientWidth * dpr / 10;// 设置viewport，进行缩放，达到高清效果metaEl.setAttribute('content', 'width=' + dpr * docEl.clientWidth + ',initial-scale=' + scale + ',maximum-scale=' + scale + ', minimum-scale=' + scale + ',user-scalable=no');// 设置data-dpr属性，留作的css hack之用docEl.setAttribute('data-dpr', dpr);// 动态写入样式docEl.firstElementChild.appendChild(fontEl);fontEl.innerHTML = 'html&#123;font-size:' + rem + 'px!important;&#125;';// 给js调用的，某一dpr下rem和px之间的转换函数window.rem2px = function(v) &#123; v = parseFloat(v); return v * rem;&#125;;window.px2rem: function(v) &#123; v = parseFloat(v); return v / rem;&#125;;window.dpr = dpr;window.rem = rem; 以上设置是为了保证，1个css像素占据一个物理像素。如果有一个区块，在psd文件中量出：宽高750×300px的div，那么如何转换成rem单位呢？如果scale是1，对于iphone6来说就是取一半，如果scale是0.5，量出多少是多少，换句话说就是设计稿的宽度W=docEl.clientWidth * dpr，对于不符合的设计稿，计算公式如下：我们现在写页面参考的机型一般是iphone4以上，dpr一般都是2，所以按照以上写法其实只有viewport的宽度在起作用，但是如果遇到宽度和dpr都不一样的时候，两者的倍数都会起作用，如果遇到iphone3这样的，宽度不变而dpr变化的，它上面的元素就会比iphone4要小，遇到这样的机型，如果不改变scale，样式有可能出问题！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端之webp图片]]></title>
      <url>http://yoursite.com/2016/04/27/image-to-webp/</url>
      <content type="text"><![CDATA[webp是什么？WebP格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。但WebP是一种有损压缩。相较编码JPEG文件，编码同样质量的WebP文件需要占用更多的计算资源。 目前使用情况国外的网站：Youtube、Facebook.etc国内的网站：腾讯、淘宝、美团等 webp兼容性支持chrome opera4s uc5 uc5s uc6 uc6s uc华为荣耀6 qq内置浏览器 微信 uc 自带浏览器魅族 微信 uc 自带浏览器三星（Galay S4） uc 自带浏览器 QQ浏览器红米1s（andr4.3） uc QQ浏览器-v6.4.1 自带浏览器 不支持58app-v6.5.74s safari5 safari5s safari6 safari6s safari5s qq内置浏览器6 qq内置浏览器6s qq内置浏览器QQ浏览器-v6.0QQ浏览器-v6.45微信5s微信6微信6s微信5s 高速浏览器 如何转换智图iSpartalibwebp 如何使用js检测，准备两套图片路径var kTestImages = &#123; lossy: "UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", lossless: "UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==", alpha: "UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==", animation: "UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA"&#125;;var img = new Image();img.onload = function () &#123; var result = (img.width &gt; 0) &amp;&amp; (img.height &gt; 0); callback(feature, result);&#125;;img.onerror = function () &#123; callback(feature, false);&#125;;img.src = "data:image/webp;base64," + kTestImages[feature];&#125; 使用webp.js插件将会捕捉页面中使用WebP格式的img元素，并用Flash进行替换。图像的解码及显示都在Flash中完成，因此目前版本对CSS设置的背景图片无效。当然，作为JPEG格式的替换，只有对较大的图像使用才有意义，否则过多的解码将消耗大量的资源。3、用html5中提供的picture元素选择图片格式（浏览器支持的情况不好） server-response（Accept和varry）Acceptiphone4suc无Accept请求头Safari Accept:*/*微信 Accept:*/*QQ浏览器-v6.4 Accept:*/*小米4uc：Accept:image/webp自带浏览器：Accept:image/webpchrome：Accept:image/webpQQ浏览器：Accept:image/webp并不是所有的请求头都包含images/webp 目前只有opera有 varry(client) &gt; Accept: image/jpeg, image/png, image/mif(server) &gt; Content-Type: image/mif &gt; Vary: Accept &gt; (object) 优势WebP is a new image format that provides lossless and lossy compression for images on the web. WebP lossless images are 26% smaller in size compared to PNGs. WebP lossy images are 25-34% smaller in size compared to JPEG images at equivalent SSIM index. WebP supports lossless transparency (also known as alpha channel) with just 22% additional bytes. Transparency is also supported with lossy compression and typically provides 3x smaller file sizes compared to PNG when lossy compression is acceptable for the red/green/blue color channels. 参考文献：WebP 探寻之路A new image format for the WebDeploying New Image Formats on the WebHow To Reduce Image Size With WebP Automagically让你的页面支持WebP图像]]></content>
    </entry>

    
  
  
</search>
