<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[react-redux详解]]></title>
      <url>http://yoursite.com/2016/12/06/react-redux%E8%AF%A6%E8%A7%A3/</url>
      <content type="text"><![CDATA[connect 拥有三个参数mapStateToProps， mapDispatchToProps， mergeProps， options mapStateToProps 外部的数据即state对象转换为UI组件的参数 mapStateToProps是一个函数，执行后应该返回一个对象，这个对象会与组件的props合并。 mapStateToProps会订阅Store，每当state更新的时候，就会自动执行，重新计算UI组件的参数，从而触发UI组件的重新渲染。 mapStateToProps的第一个参数总是state对象，还可以使用第二个参数ownProps，代表UI组件的props对象。 connect方法可以省略mapStateToProps参数，那样的话，UI组件就不会订阅Store，就是说Store的更新不会引起UI组件的更新。 mapDispatchToProps 用户发出的动作变为Action对象，从UI组件传出去 如果作为函数会得到dispatch和ownProps两个参数，mapDispatchToProps执行后应该返回一个对象，这个对象会与组件的props合并。 如果mapDispatchToProps是一个对象，会先用bindActionCreators处理，之后合并到props中。 如果你省略这个mapDispatchToProps参数，默认情况下，dispatch会注入到你的组件props中。 mergeProps 拥有三个参数stateProps，dispatchProps，ownProps 如果指定了这个参数，mapStateToProps与mapDispatchToProps的执行结果和组件自身的props将传入到这个回调函数中。该回调函数返回的对象将作为props传递到被包装的组件中。 options pure = true: 如果为true，connector将执行shouldComponentUpdate并且浅对比mergeProps的结果，避免不必要的更新，前提是当前组件是一个“纯”组件，它不依赖于任何的输入或state而只依赖于props和Redux store的state。默认值为true。 withRef = false: 如果为true，connector会保存一个对被包装组件实例的引用，该引用通过 getWrappedInstance()方法获得。默认值为false。 组件Provider在根组件外面包了一层，这样一来，App的所有子组件就默认都可以拿到state了。它的原理是React组件的context属性，请看源码:class Provider extends Component &#123; getChildContext() &#123; return &#123; store: this.props.store &#125;; &#125; render() &#123; return this.props.children; &#125;&#125;Provider.childContextTypes = &#123; store: React.PropTypes.object&#125; 组件可以获取store如下：const &#123; store &#125; = this.context;this.unsubscribe = store.subscribe(() =&gt;&#123; //todo something&#125;);组件名.contextTypes = &#123;//必须加，否则context为空 store: React.PropTypes.object&#125;;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redux中间件]]></title>
      <url>http://yoursite.com/2016/12/05/redux%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      <content type="text"><![CDATA[redux-thunkreturn function (next) &#123; return function (action) &#123; if (typeof action === 'function') &#123; return action(dispatch, getState, extraArgument); &#125; return next(action); &#125;;&#125;; 加了一个对action是函数的特殊处理！ redux-logger打印各种信息]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[redux详解]]></title>
      <url>http://yoursite.com/2016/12/05/redux/</url>
      <content type="text"><![CDATA[createStore这个函数有三个参数分别是reducer（function），preloadedState和enhancer(可选，function)，如果enhancer存在，那么就会走下面的逻辑：return enhancer(createStore)(reducer, preloadedState); 一旦使用中间件就会使用上面的函数，store就会在这个函数中生成！如果preloadedState是函数，enhancer是undefined，两者的值会被调换！enhancer可以看做是一种自定义的处理方式！最后返回dispatch、subscribe、getState和replaceReducer这四个函数，state和Listener都存在于createStore内部，作为闭包的一个引用！ subscribe绑定监听事件，把所有的事件函数都存放于nextListeners中，并且返回一个解绑事件的函数。 dispatchaction必须是一个对象，且type不能是undefined，执行时会把当前的state和action作为参数传入reducer中，生成新的state,此时也会执行nextListeners收集到的事件函数！注意：dispatch会在createStore初始化时执行一次！ getState获取当前的state replaceReducer初始化了createStore之后，提供一次更换reducer的机会。 bindActionCreatorsbindActionCreator处理单个actionCreator,此时actionCreator必须是函数！function bindActionCreator(actionCreator, dispatch) &#123; return function () &#123; return dispatch(actionCreator.apply(undefined, arguments)); &#125;;&#125; bindActionCreators也有这两个参数actionCreators和dispatch，一般返回一个触发dispatch的对象，此处直接看代码吧！if (typeof actionCreators === 'function') &#123; return bindActionCreator(actionCreators, dispatch);&#125;var keys = Object.keys(actionCreators);var boundActionCreators = &#123;&#125;;for (var i = 0; i &lt; keys.length; i++) &#123; var key = keys[i]; var actionCreator = actionCreators[key]; if (typeof actionCreator === 'function') &#123; boundActionCreators[key] = bindActionCreator(actionCreator, dispatch); &#125;&#125; compose1、不传参数，返回一个函数，此函数特点是直接返回一个传入的参数2、传入一个参数，直接返回这个参数3、传入不少于两个的参数，参数在函数内部会转化为一个数组，此函数会返回另外一个函数：return function () &#123; return rest.reduceRight(function (composed, f) &#123; return f(composed); &#125;, last.apply(undefined, arguments));&#125; 此函数可以当做一种数据流使用，要求compose传入的参数都是函数，那么上面这个函数的参数传入compose最后一个函数参数中，执行的结果再传入compose倒数第二个函数参数中，执行的结果再传入倒数第三个…以此类推，最后获得结果！ applyMiddlewareapplyMiddleware参数是传入的一些中间件，函数内部嵌套了两层函数用于生成store，同时也生成了一个对象：var middlewareAPI = &#123; getState: store.getState, dispatch: function dispatch(action) &#123; return _dispatch(action); &#125;&#125;; 这个对象会作为每个中间件的参数，执行后重新生成一个数组chain，chain会作为参数传入compose中，compose最后一个参数的参数是store.dispatch，最后返回一个结果_dispatch，用这个_dispatch替换store的dispatch! 注意：中间件一般是只修改dispatch，middlewareAPI会传入每个中间件中，这样中间件就可以获取getState和dispatch的引用！ combineReducers参数是一个对象reducers，会把其中值是函数的k-v对提取出来，重新生成一个对象finalReducers，处理过程直接看代码：var hasChanged = false;var nextState = &#123;&#125;;for (var i = 0; i &lt; finalReducerKeys.length; i++) &#123; var key = finalReducerKeys[i]; var reducer = finalReducers[key]; var previousStateForKey = state[key]; var nextStateForKey = reducer(previousStateForKey, action); nextState[key] = nextStateForKey; hasChanged = hasChanged || nextStateForKey !== previousStateForKey;&#125;return hasChanged ? nextState : state; 一旦nextStateForKey发生变化，就会返回新的state！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Promise实现逻辑]]></title>
      <url>http://yoursite.com/2016/11/27/Promise-logic/</url>
      <content type="text"><![CDATA[我们都知道promise可以很好的解决异步嵌套的问题，使代码更有可读性，但是一直没去研究promise的实现逻辑，最近看了一下es6-promise源码，那么下面简单介绍一下实现思想！ PromisePromise处理流程如下：一般的用法都会new一个promise对象：new Promise(function(resolve,reject)&#123; if(ok)&#123; resolve(value) &#125;else&#123; reject(reason) &#125;&#125;) Promise构造函数只有一个参数，类型为function，而此函数有两个参数也是函数类型即resolve和reject，他们两个是源码中定义的。拒绝时的状态为reject就不说了，resolve是成功时的处理函数，他会根据value进行处理 value是普通的值，他就会挂在到Promise对象的_result属性上 value是Promise对象，那么他就会把value的_result值赋值给外层的Promise对象的_result属性 value是对象且带有then函数属性，那么value就会被当做一个类似Promise的对象，运行此对象then的结果赋值给Promise对象的_result属性上 挂在Promise对象的_result属性上的值是为了传入后续的then函数中 ThenThen处理流程如下：Then有两个函数参数，使用哪一个完全依据上个Promise运行的状态。Then并不是在主线程开始运行的，在源码中专门有一个数组用于收集Then的处理。 每个Then的处理都会单独new一个新的Promise对象 第一个Then会传入数组，并启动异步执行开关 其余的Then处理会挂载到上一个Promise对象的属性上 通过遍历，当一个Then处理完成，下一个Then的处理和上一个Then处理的值就会存入数组中并且开始遍历执行，直到处理完所有的Then 在处理Then过程中value也会按照Promise方式处理 Promise.allall的处理思想和以上一致，唯一的区别是会遍历传入的数组，对每一个进行处理，在处理完全后，把值传入Then中，只不过此时的value是数组罢了 polyfill其作用是检测当前环境存不存在Promise，如果不存在就会引入源码中的Promise。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[next主题vendors报错404]]></title>
      <url>http://yoursite.com/2016/11/14/nextThemeProblemRepair/</url>
      <content type="text"><![CDATA[本地预览没问题，deploy后主页显示大面积空白最近小伙伴上传博客，发现主页显示大面积空白，打开控制台后发现vendors目录下面的js各种404，但是在github上文件是存在的，究其原因可能是GitHub Pages过滤掉了source/vendors目录的访问。 解决办法首先修改source/vendors为source/lib，然后修改_config.yml，将_internal:vendors修改为_internal:lib然后修改next底下所有引用source/vendors路径为source/lib。这些地方可以通过文件查找找出来。主要集中在这几个文件中。1. Hexo\themes\next.bowerrc 2. Hexo\themes\next.gitignore 3. Hexo\themes\next.javascript_ignore 4. Hexo\themes\next\bower.json 。修改完毕后，刷新重新g一遍就ok啦。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[一个基于自身业务的前端简单生产工具]]></title>
      <url>http://yoursite.com/2016/11/13/gulp-develop-tool/</url>
      <content type="text"><![CDATA[背景目前网上有众多的构建工具，比如webpack、gulp、grunt还有fis等等，除了grunt，小生都有尝试过。先前本司一众大神推广过fis，进行过很多期讲座培训，由于公司的小白比较多，显然效果不太好，原因如下： 很多人仓促去听讲座，根本没看文档，所以听的云里雾里 fis相对比较笨重，有一定的学习成本，配置眼花缭乱 最最主要的是需求，习惯于用各种小工具搞定生产中的环节，还不容易出问题，而且效率还不错，fis要是出问题了，可能要调试半天，对于小白来说很头疼 大神们陶醉于技术的钻研，却忽略了小白们的接收能力，所有的讲座都有一个特点，就是太泛，无法深入每个细节点。大神们所有的配置都是一路畅通，但是到了小白这里各种报错，大神们认为小白应该自己看，那小白们很有可能就不看了！ 那么作者选择gulp作为构建化工具有以下几点原因： gulp文档很少，语法简单，对于我们小白来说，或多或少都会点，不见得会写，至少都能看得懂 gulp很轻巧，开源插件众多，小白们瞜一眼gulp文件，基本就知道各种task是干什么的，加以配置注释，那么自己配置应该就没什么问题了，再熟悉一点自己都可以去拓展 配置gulpfile.js创建目录搬砖首先要有文件夹，所以这里就按照小生的业务来建立文件夹目录，如下： html src css js img dist css js img mock tool doc html文件夹存放html文件，src为开发目录，包括css、js和img，因为这三者都需要经过处理，所以处理后会放入dist目录； mock是模拟数据存放的目录，一般开发，fe需要后端提供一些接口，但是往往因为开发速度不一样，rd不能及时提供，所以fe可以起一个服务，把模拟数据放在此处； tool可以存放自己的一些小工具用于其他的开发功能 doc存放需求文档等文档类的文件//创建开发目录gulp.task('g-init', function() &#123; var dirs = [dirPaths.html, dirPaths.css.src, dirPaths.js.src, dirPaths.doc, dirPaths.img.src, dirPaths.tool]; dirs.forEach(dir =&gt; &#123; mkdirp.sync(dir); &#125;)&#125;); 创建目录采用了mkdirp这个插件，路径都写在了dirs这个数组内，运行命令：gulp g-init 就可以完成以上目录结构的创建，task的名字可以自己随意起！ 处理css//处理sass文件gulp.task('g-css', function() &#123; return gulp.src(dirPaths.css.src + '/**/*.scss') .pipe(sourcemaps.init())//生成map .pipe(sass(&#123;//编译sass文件 outputStyle: 'compressed'//压缩 &#125;).on('error', sass.logError)) .pipe(autoprefixer())//添加前缀 .pipe(sourcemaps.write()) .pipe(rename(&#123;&#125;))//重命名 .pipe(gulp.dest(dirPaths.css.dist));&#125;); 看见以上代码的注释就应该知道他们是做什么的，也有一些人可能没有使用sass，那么只要自己稍微改动一下应该就没问题了 处理img//处理图片gulp.task('g-image', function() &#123; return gulp.src(dirPaths.img.src + '/**/*') .pipe(imagemin())//压缩 .pipe(gulp.dest(dirPaths.img.dist))&#125;); 这个命令只是对图片做了压缩，采用了gulp-imagemin插件，效果还行，如果不满意压缩效果，自己可以再试试其他的插件 处理整个style//处理css和imggulp.task('g-style', ['g-css', 'g-image'], function() &#123; gulp.src(dirPaths.css.dist + '/**/*.css') .pipe(spriter(spriteConfig))&#125;); 我这里把css和img都归为style，这个任务的功能就是生成和替换雪碧图，前提是先运行g-css和g-image，在把处理好的css和img文件放入dist目录下，再对他们做雪碧图的处理。spriter是我自己改装的插件gulp-cross-spriter的引用，具体功能和配置都有很详细的说明，可以点进去凑凑。多说一句，此插件readme全文都是中文，主要是为方便自己书写，也方便同胞查阅，如果要说我英语不好，我也承认，我确实对英文文档的某些语句理解挠头，不过对于英语过六级，经过研究生生涯洗礼的我来说搞一篇英文的说明文档，问题应该不大。 处理js//处理js文件gulp.task('g-js', function() &#123; gulp.src(dirPaths.js.src + '/**/*.js') .pipe(jshint())//语法检查 .pipe(jshint.reporter(stylish))//控制台报错输出的样式 .pipe(uglify()) //压缩，有一定的语法检测能力，如果语法错的太离谱，这里可能会报错 .pipe(gulp.dest(dirPaths.js.dist));&#125;); 这里对js做了语法检查和压缩，当前目录需要配置.jshintrc文件，具体相关配置请查阅文档 实时刷新gulp自带的监听功能单一，这里借助gulp-connect起一个本地的服务，可以做到html文件的试试刷新（仅仅html文件）//启动服务器gulp.task('g-connect', function() &#123; connect.server(&#123; root: serverConfig.root, //设置根目录 livereload: serverConfig.livereload, //启动实施监控 port: serverConfig.port, //设置端口 name: serverConfig.name //设置服务器名字 &#125;);&#125;);//重新加载gulp.task('g-reload', function() &#123; gulp.src(dirPaths.devPath + '/**/*.*') .pipe(connect.reload())&#125;)//监听gulp.task('g-watch', function() &#123; //watch 只能监听现存的文件对于新建文件 无法监听 gulp.watch(dirPaths.html + '/**/*.html', ['g-reload']); gulp.watch(dirPaths.js.src + '/**/*.js', ['g-reload', 'g-js']); gulp.watch(dirPaths.css.src + '/**/*.scss', ['g-reload', 'g-style']);&#125;); 那么本地服务配合watch监听，就可以在代码保存后试试刷新页面，但是监听只能监听存在的文件，对于后来新建的文件必须重新启动才行！ 默认taskgulp.task('default', ['g-connect', 'g-watch', 'g-openbrowser']); 这样只要一个gulp命令就可以建立本地服务，启动监听，并且帮你打开页面！ 综述其实开发就两条命令：gulp g-init gulp 一个是建立文件夹，一个是监听！这里有个完整的栗子，可以凑凑，我把配置都放在了一个文件里面，因为代码量并不是很多，我只想让开发者拷贝更少的文件，如果想要把配置都放在另外的文件下，也是莫问题滴！我这个目录下写了很多gulp插件的栗子，方便小白查阅！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack.plugin]]></title>
      <url>http://yoursite.com/2016/10/18/webpack-plugin/</url>
      <content type="text"><![CDATA[bell-on-bundler-error-pluginbell-on-bundler-error-plugin会通知您在打包构建过程中的错误function BellOnBundlerErrorPlugin () &#123; &#125;BellOnBundlerErrorPlugin.prototype.apply = function(compiler) &#123; if (typeof(process) !== 'undefined')&#123; compiler.plugin('done', function(stats) &#123; if (stats.hasErrors()) process.stderr.write('\x07') &#125;) compiler.plugin('failed', function(err) &#123; process.stderr.write('\x07') &#125;) &#125;&#125;module.exports = BellOnBundlerErrorPlugin CommonsChunkPluginWebpack中将打包后的文件都称之为“Chunk”。这个插件可以将多个打包后的资源中的公共部分打包成单独的文件。智能提取公共部分来方便多页面之间进行复用!先看一个简单的例子，运行一下，从下图可知，公共部分已经被独立出来，在html必须先被加载！提取的公共部分的common，还可以再和其他文件继续提取common，来看一个稍微复杂的例子,在index.html中改变js的引用文件，就可以看见效果！ page5.html: commons.js, ap1.js page4.html: commons.js, ap2.js page3.html: p3.js page2.html: commons.js, admin-commons.js, p1.js page1.html: commons.js, admin-commons.js, p2.js extract-text-webpack-plugin独立出css样式，单独打包CSS，通过link引入样式而不是放在style标签内 ExtractTextPlugin.extract([notExtractLoader], loader, [options]) noExtractLoader可选参数，未提取的css会被这个loader处理。loader列表，将资源转换为导出的css module，必选ExtractTextPlugin.extract会在这个loader列表前插入一个loader，并且最后会执行loader列表所返回的module,本人尝试这个插件，无论同一个入口中引入多少css文件，都被打包成一个css，不同的入口会单独打包一个，看一个例子，在这个例子中还增加了压缩js的功能。 webpack.DefinePlugin可以为js定义变量，这个变量是webpack自动生成插入到我们的代码中的new webpack.DefinePlugin(&#123; 'process.env': &#123; NODE_ENV:JSON.stringify(env) &#125;, __DEV__:dev&#125;) DefinePlugin中可以传入一个对象，对象的key会被定义在我们的代码中，对应的value，就是key在代码中对应的值，值得注意的是字符串需要JSON.stringify包裹，否则这个值在代码中会生成一个变量，而不是字符串，导致代码报错，看个例子！ UglifyJsPluginnew webpack.optimize.UglifyJsPlugin(&#123; compress: &#123; warnings: false//去掉压缩过程中的提示 &#125;, beautify: true,//是否格式化 mangle: &#123; except: ['$super', '$', 'exports']//可以指定哪些变量name不混淆， &#125;, output: &#123; comments: false//是否保留注释,默认为false &#125;&#125;) 上面一些小的功能小生都加了注释，但是是否混淆小生没有找到开关!]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[webpack.learning]]></title>
      <url>http://yoursite.com/2016/10/17/webpack-learning/</url>
      <content type="text"><![CDATA[安装Node作为前端，没用过Node，只能说是个十足的菜鸟！ 全局安装webpack$ npm install webpack -g 运行例子进入文件，首先运行 npm install，安装所需要的依赖，然后可以打开example1.webpack文件夹，运行下面的命令：$ webpack src/index.js dist/index.js 之后打开index.html就可以看见运行效果！ 生成配置文件webpack.config.js查看第二个例子,进入文件，只要运行如下命令即可，$ webpack 此时webpack就会自动运行这个配置文件,如果想配置多个config文件，用如下命令：$ webpack --config webpack.config.prod.js 编译React安装一下插件$ npm install babel-loader babel-core babel-preset-es2015 babel-preset-stage-0 babel-preset-react babel-polyfill --save-dev$ npm install react react-dom --save babel-core是babel6的基础模块,babel-loader和babel-preset-es2015用于编译ES6语法的js，babel-preset-stage-0主要是应对ES7语法标准的插件，babel-preset-react用于编译react。先看一个栗子 babel-polyfillBabel默认只转换新的JavaScript句法（syntax），而不转换新的API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。举例来说，ES6在Array对象上新增了Array.from方法。Babel就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。 引入代码：import 'babel-polyfill';// 或者require('babel-polyfill'); webpack打包css安装如下几个loader：$ npm install style-loader css-loader sass-loader --save-dev style-loader 将css插入到页面的style标签 css-loader 是处理css文件中的url()等 sass-loader 是将sass文件编译成css webpack-dev-server安装：$ npm install webpack-dev-server -g 启动：$ webpack-dev-server --content-base ./ –content-base ./ 参数表示将当前目录作为 server 根目录。 命令启动过后，会在 8080 端口启动一个 http 服务，通过访问 http://localhost:8080/index.html 可以访问 index.html 内容。此时修改内容，刷新页面，页面内容的改变并没有呈现出来，因为webpack-dev-server的打包结果是放在内存中的，此时可以在webpack.config.js的output中加上publicPath，现在再刷新页面就可以看见效果了！ 实时刷新1、Iframe 模式 修改访问的路径： http://localhost:8080/index.html -&gt; http://localhost:8080/webpack-dev-server/index.html 。这个时候每次修改代码，打包完成过后都会自动刷新页面。 不需要额外配置，只用修改路径 应用被嵌入了一个 iframe 内部，页面顶部可以展示打包进度信息 因为 iframe 的关系，如果应用有多个页面，无法看到当前应用的 url 信息 2、inline 模式 启动 webpack-dev-server 的时候添加 –inline 参数 需要添加 –inline 配置参数 没有顶部信息提示条，提示信息在控制台中展现 热加载webpack-dev-server 还提供了模块热加载的方式，在不刷新浏览器的条件下，应用最新的代码更新，启动 webpack-dev-server 的时候添加 –inline –hot 参数就可以体验。$ webpack-dev-server --inline --hot 也可以在webpack.config.js中配置plugins: [ // 需要手动添加 HotModuleReplacementPlugin , 命令行的方式会自动添加 new webpack.HotModuleReplacementPlugin()],devServer: &#123; hot: true, inline: true&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[表单提交问题]]></title>
      <url>http://yoursite.com/2016/05/12/form-submit/</url>
      <content type="text"><![CDATA[表单提交方式 input[type=submit] button[type=submit] input[type=image] form对象调用submit()方法 submit事件 阻止表单提交 设置提交按钮disabled属性 调用submit事件 1、调用submit方法的时候不会触发submit事件，但是与之对应的有一个重置表单方法reset，调用后会触发reset事件。2、在点击提交按钮的时候，先触发click事件，再触发submit事件3、type=image的表单元素通过表单 elements 属性是获取不到的 submit事件demo1绑定myform.onsubmit = function()&#123; return false;&#125; 这种方式直接返回false即可 demo2绑定function addListener(element, type, handler)&#123; if (!element) &#123; return; &#125; if (element.addEventListener) &#123; element.addEventListener(type, handler, false); &#125; else &#123;//for ie element.attachEvent("on" + type, handler); &#125; &#125;addListener(obj, 'submit', function()&#123; return false&#125;); 以上提交方式在ie下可以阻止表单提交，但是在ff或者chrome却不行，究其原因是addListener中的事件处理函数没有返回值，写了也白写！ The listener parameter is a EventListener object.Object EventListener：This is an ECMAScript function reference. This method has no return value. The parameter is a Event object. 解决方法：addListener(obj, 'submit', function(e)&#123; var e = e || window.event; if(e.preventDefault)&#123; e.preventDefault(); &#125;else&#123; e.returnValue = false; &#125;&#125;); 脚本处理完自己的工作后由元素处理事件，元素可以通过事件对象判断是否执行默认操作！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[PS一键切图]]></title>
      <url>http://yoursite.com/2016/05/11/ps-shortCut/</url>
      <content type="text"><![CDATA[作为一名前端，明天都在做着重复的切图工作，如果方法不佳，会浪费大把的生命，下面小生介绍一个切图小技巧，提高一下工作效率！ 步骤 点击下载一键切图 载入：菜单栏—&gt;窗口—&gt;动作，按照此步骤打开动作面板，点击面板右上角（见图中红框），出现下拉菜单，选择‘载入动作’，然后将刚才下载的‘一键切图动作’载入。 选择一张psd图，选中其中一个图层，按F2，奇迹就会发生！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ESL之config配置]]></title>
      <url>http://yoursite.com/2016/05/10/esl-config/</url>
      <content type="text"><![CDATA[config默认配置var requireConf = &#123; baseUrl: './', paths: &#123;&#125;, config: &#123;&#125;, map: &#123;&#125;, packages: [], waitSeconds: 0, noRequests: &#123;&#125;, urlArgs: &#123;&#125; &#125;; 所有的配置初始化在createConfIndex函数中完成 baseUrl在整个源码中只有以下两处出现过：createConfIndex对baseUrl的处理//处理末尾有或者没有‘/’requireConf.baseUrl = requireConf.baseUrl.replace(/\/$/, '') + '/'; 对于baseUrl，末尾可以有“/”也可以没有！ 在toUrl函数中拼接模块的url// 相对路径时，附加baseUrl(url前面不能有"/") if (!/^([a-z]&#123;2,10&#125;:\/)?\//i.test(url)) &#123; url = requireConf.baseUrl + url; &#125; 在加载模块时，会把所有的要通过script标签加载define文件的url前面拼接baseUrl paths配置 require.config(&#123; baseUrl: "http://j2.58cdn.com.cn/m58/njs/", paths: &#123; test: "pkg/house" &#125; &#125;); require(['test/ershoufang_list'], function() &#123; console.log('pkg ershoufang_list callback') &#125;); createConfIndex对paths的处理pathsIndex = createKVSortedIndex(requireConf.paths);//处理结果pathsIndex = &#123; k: "test", reg: /^test(\/|$)/, //前缀匹配 v: "pkg/house"&#125; toUrl的处理// paths处理和匹配var isPathMap;// 将url中的key用pathsIndex中value替换indexRetrieve(id, pathsIndex, function(value, key) &#123; url = url.replace(key, value); isPathMap = 1;&#125;);// 如果pathsIndex没有匹配，就用packagesIndex处理urlif (!isPathMap) &#123; indexRetrieve(id, packagesIndex, function(value, key, item) &#123; url = url.replace(item.name, item.location); &#125;);&#125; 相当于在url中用paths的key作为模块id的一部分，而其value才是url真实的一部分，并且packages和paths是互斥的！ packages配置require.config(&#123; baseUrl: "http://j2.58cdn.com.cn/m58/njs/", packages: [&#123; name: "test", location: "pkg/house", main: "ershoufang_list", &#125;] &#125;); require(['test'], function() &#123; console.log('pkg ershoufang_list callback') &#125;); createConfIndex对packages的处理packagesIndex = []; each(requireConf.packages, function(packageConf) &#123; var pkg = packageConf; if (typeof packageConf === 'string') &#123; pkg = &#123; name: packageConf.split('/')[0], location: packageConf, main: 'main' &#125;; &#125; pkg.location = pkg.location || pkg.name; pkg.main = (pkg.main || 'main').replace(/\.js$/i, ''); pkg.reg = createPrefixRegexp(pkg.name); //前缀匹配name packagesIndex.push(pkg); &#125; ); packagesIndex.sort(descSorterByKOrName); packagesIndex一般会有name、location、main和reg这四个属性 在normalize中//packagesIndex中某项的name属性与moduleId相同，就将main属性拼接在moduleId之后 each(packagesIndex, function(packageConf) &#123; var name = packageConf.name; if (name === moduleId) &#123; moduleId = name + '/' + packageConf.main; return false; &#125; &#125; ); packagesIndex的name属性与moduleId匹配时，把main属性拼接上 toUrl的处理// paths处理和匹配var isPathMap;// 将url中的key用pathsIndex中value替换indexRetrieve(id, pathsIndex, function(value, key) &#123; url = url.replace(key, value); isPathMap = 1;&#125;);// 如果pathsIndex没有匹配，就用packagesIndex处理urlif (!isPathMap) &#123; indexRetrieve(id, packagesIndex, function(value, key, item) &#123; url = url.replace(item.name, item.location); &#125;);&#125; 如果匹配，就用packagesIndex的location属性替换url中的name部分 map配置require.config(&#123; baseUrl: "http://j2.58cdn.com.cn/m58/njs/", map: &#123; "pkg/house/ershoufang_list": &#123; "test": "mod/common" &#125; &#125; &#125;); require(['pkg/house/ershoufang_list'], function() &#123; console.log('pkg ershoufang_list callback') &#125;); createConfIndex中的处理mappingIdIndex = createKVSortedIndex(requireConf.map, 1); each(mappingIdIndex, function(item) &#123; item.v = createKVSortedIndex(item.v); &#125; ); normalize中的处理// mappingIdIndex=[&#123;reg1:xx,k1:xx,v1:&#123;reg2:xx,k2:xx,v2:xx&#125;&#125;]，reg1匹配baseId，reg2匹配moduleId,将moduleId中的k2用v2替换 indexRetrieve(baseId, mappingIdIndex, function(value) &#123; indexRetrieve(moduleId, value, function(mdValue, mdKey) &#123; moduleId = moduleId.replace(mdKey, mdValue); &#125; ); &#125;); map就是paths多一层，先匹配父模块的id，再匹配子模块的id，最后替换的是子模块的id urlArgs配置require.config(&#123; // ... urlArgs: 'v=2.0.0' // 指定所有模块的路径后参数&#125;);require.config(&#123; // ... urlArgs: &#123; common: '1.2.0' // 为common和common下的子模块指定路径后参数 &#125;&#125;); createConfIndex中的处理urlArgsIndex = createKVSortedIndex(requireConf.urlArgs); require.config中的处理if (newValue) &#123; if (key === 'urlArgs' &amp;&amp; typeof newValue === 'string') &#123; defaultUrlArgs = newValue; &#125; else &#123; 在urlArgs设置为字符串时，会赋值给defaultUrlArgs toUrl中的处理// 拼接查询字段，如果urlArgsIndex拼接了，defaultUrlArgs就不用拼接 var isUrlArgsAppended; indexRetrieve(id, urlArgsIndex, function(value) &#123; appendUrlArgs(value); &#125;); defaultUrlArgs &amp;&amp; appendUrlArgs(defaultUrlArgs); urlArgs主要作用是在模块的url上拼接一个查询字符串 waitSeconds配置require.config(&#123; // ... waitSeconds: 5&#125;); 指定等待的秒数。超过等待时间后，如果有模块未成功加载或初始化，将抛出 MODULE_TIMEOUT 异常错误信息。 noRequests配置require.config(&#123; baseUrl: "http://j2.58cdn.com.cn/m58/njs/", noRequests: &#123; "pkg/house/ershoufang_list": ["pkg/house/ershoufang_list"] &#125; &#125;); require(['pkg/house/ershoufang_list'], function() &#123; console.log('pkg ershoufang_list callback') &#125;); createConfIndex中的处理noRequestsIndex = createKVSortedIndex(requireConf.noRequests); each(noRequestsIndex, function(item) &#123;//[&#123;reg:xx,k:xx,v:[xx,xx]&#125;] var value = item.v; var mapIndex = &#123;&#125;; item.v = mapIndex; if (!(value instanceof Array)) &#123; value = [value]; &#125; each(value, function(meetId) &#123; //[&#123;reg:xx,k:xx,v:&#123;xx:1,xx:1&#125;&#125;] mapIndex[meetId] = 1; &#125;); &#125;); actualGlobalRequire函数中的处理each(pureModules, function(id) &#123; var meet; // noRequestsIndex = //[&#123;reg:xx,k:xx,v:&#123;xx:1,xx:1&#125;&#125;] // reg要匹配id，v值的属性还要存在一个pureModules indexRetrieve(id, noRequestsIndex, function(value) &#123; meet = value; &#125;); if (meet) &#123; if (meet['*']) &#123; noRequestModules[id] = 1; &#125; else &#123; each(pureModules, function(meetId) &#123; if (meet[meetId]) &#123; noRequestModules[id] = 1; return false; &#125; &#125;); &#125; &#125; &#125;); nativeRequire( pureModules, function() &#123; //require回调函数所在 each(normalizedIds, function(id, i) &#123; if (id == null) &#123; normalizedIds[i] = normalize(requireId[i], baseId); // 对有感叹号的id做处理 &#125; &#125;); nativeRequire(normalizedIds, callback, baseId); &#125;, baseId, noRequestModules ); native中的处理each(ids, function(id) &#123; if (!(BUILDIN_MODULE[id] || modIs(id, MODULE_DEFINED))) &#123; modAddDefinedListener(id, tryFinishRequire); //为没有达到MODULE_DEFINED的模块增加监听函数 if (!noRequests[id]) &#123; //若存在就不加载 (id.indexOf('!') &gt; 0 ? loadResource : loadModule)(id, baseId); &#125; &#125;&#125;); noRequests的作用就是拒绝加载require中引入的模块]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[ESL模块处理过程]]></title>
      <url>http://yoursite.com/2016/05/10/esl-run-route/</url>
      <content type="text"><![CDATA[ESL是什么ESL是一个浏览器端、符合AMD的标准加载器，适合于现代web浏览器端应用的入口与模块管理。相比于RequireJS拥有以下优点： 体积更小 性能更高 更健壮 不支持非浏览器端使用 依赖模块用时定义 ESL模块加载详解 esl.js加载模块过程如下： 1、require引入模块的入口，调用nativeRequire，在这个函数中通过tryFinishRequire绑定require的callback，并且把tryFinishRequire作为监听函数绑在入口模块上； 2、nativeRequire通过loadModule加载入口js文件即define文件，并且通过onload绑定一个监听函数loadedListener； 3、define函数生产出模块的id、依赖模块和callback； 4、等到define文件执行完成，loadedListener会通过completePreDefine将模块数据加入到modModules中； 5、最后通过modAnalyse分析依赖模块的属性以及处理url，其中会调用modAutoInvoke（核心函数）处理最后的结果，如果依赖的模块还存在没有加载的，再次统一放入nativeRequire中，循环上面的过程！ 核心函数modAutoInvoke分析//核心函数 递归设置所有模块状态为3，递归执行所有invokeFactory function modAutoInvoke() &#123; for (var id in autoDefineModules) &#123; modUpdatePreparedState(id); //一次性设置有依赖关系的模块为状态3 modTryInvokeFactory(id); &#125; &#125; autoDefineModules数组存放着作为入口的模块； modUpdatePreparedState的作用：采用递归遍历所有模块，检测依赖的模块是否都是状态3，如果是，autoDefineModules中对应的模块状态可以设置为3，如果不是，则不能设置为3； modTryInvokeFactory的作用是在autoDefineModules中模块状态达到3时，执行InvokeFactory； //invokeFactory中的两段代码 each(module.factoryDeps, function(dep) &#123; var depId = dep.absId; if (!BUILDIN_MODULE[depId]) &#123; modTryInvokeFactory(depId); //递归执行依赖模块的invokeFactory if (!modIs(depId, MODULE_DEFINED)) &#123; //所有依赖的模块必须达到MODULE_DEFINED factoryReady = 0; return false; &#125; &#125; factoryDeps.push(depId); //达到MODULE_DEFINED状态的模块被推入factoryDeps中 &#125; ); //所有依赖的模块必须达到MODULE_DEFINED就可以执行下面的代码 if (factoryReady) &#123; try &#123; var args = modGetModulesExports( //依赖模块的输出 factoryDeps, &#123; require: module.require, exports: module.exports, module: module &#125; ); var factory = module.factory; var exports = typeof factory === 'function' ? factory.apply(global, args) : factory; if (exports != null) &#123; module.exports = exports; &#125; module.invokeFactory = null; &#125; catch (ex) &#123;&#125; modDefined(id); //设置为状态4,执行监听函数 &#125; &#125;&#125; 以上是invokeFactory中的两段代码，这个函数的作用就是输出模块的执行结果，但是在输出自身之前必须通过modTryInvokeFactory递归所有依赖的模块，这些依赖的模块也都必须输出执行结果，赋值在exports中，供父模块调用！ 核心函数modAutoInvoke调用在整个源文件中，调用modAutoInvoke主要有两处，一个是modAnalyse最后执行，在当前模块分析完毕，状态达到2时调用，另外一处是nativeRequire中！核心思想就是在每处理一个模块，都要从入口模块递归依赖的所有模块，以达到一旦所有模块准备就绪，就可以执行require的callback函数！ demo]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[viewport]]></title>
      <url>http://yoursite.com/2016/05/07/viewport/</url>
      <content type="text"><![CDATA[viewport的概念layout viewport通俗的讲，移动设备上的viewport就是设备的屏幕上能用来显示我们的网页的那一块区域，在具体一点，就是浏览器上(也可能是一个app中的webview)用来显示网页的那部分区域，但viewport又不局限于浏览器可视区域的大小，它可能比浏览器的可视区域要大，也可能比浏览器的可视区域要小。在默认情况下，一般来讲，移动设备上的viewport都是要大于浏览器可视区域的，这是因为考虑到移动设备的分辨率相对于桌面电脑来说都比较小，所以为了能在移动设备上正常显示那些传统的为桌面浏览器设计的网站，移动设备上的浏览器都会把自己默认的viewport设为980px或1024px（也可能是其它值，这个是由设备自己决定的），但带来的后果就是浏览器会出现横向滚动条，因为浏览器可视区域的宽度是比这个默认的viewport的宽度要小的。下图是一些设备上浏览器的默认viewport的宽度。这个layout viewport的宽度可以通过 document.documentElement.clientWidth 来获取。 visual viewport它是在不同的缩放（initial-scale）情况下浏览器可视区域的大小（需要多少css像素填充），visual viewport的宽度可以通过window.innerWidth 来获取，但在Android 2, Oprea mini 和 UC 8中无法正确获取。 ideal viewport这个viewport可以理解为最适合当前机型的viewport。不同的手机的可能拥有不同的ideal viewport,一般iphone手机都是320px，但是安卓设备就比较复杂了，有320px的，有360px的，有384px的等等，关于不同的设备ideal viewport的宽度都为多少，可以到http://viewportsizes.com去查看一下，里面收集了众多设备的理想宽度。 像素的理解物理像素(physical pixel)一个物理像素是显示器(手机屏幕)上最小的物理显示单元，在操作系统的调度下，每一个设备像素都有自己的颜色值和亮度值。 设备独立像素(density-independent pixel)设备独立像素(也叫密度无关像素)，可以认为是计算机坐标系统中得一个点，这个点代表一个可以由程序使用的虚拟像素(比如: css像素)，然后由相关系统转换为物理像素。 设备像素比(device pixel ratio )定义了物理像素和设备独立像素的对应关系，它的值可以按如下的公式的得到： 设备像素比 = 物理像素 / 设备独立像素 // 在某一方向上，x方向或者y方向 在js中，dpr = window.devicePixelRatio 在css中，可以通过-webkit-device-pixel-ratio，-webkit-min-device-pixel-ratio和 -webkit-max-device-pixel-ratio进行媒体查询，对不同dpr的设备，做一些样式适配(这里只针对webkit内核的浏览器和webview)。 综合上面几个概念，一起举例说明下： 以iphone6为例：设备宽高为375×667，可以理解为设备独立像素(或css像素)。dpr为2，根据上面的计算公式，其物理像素就应该×2，为750×1334。在css像素大小不变的情况下，普通屏幕下，1个css像素 对应 1个物理像素(1:1)，retina屏幕下，1个css像素对应 4个物理像素(1:4)。 meta.viewport详解几个概念一般在做移动端页面时，会把这行代码复制到页面中。该meta标签的作用是让当前viewport的宽度等于设备的宽度，同时不允许用户对其进行缩放。一般，width设置layout viewport 的宽度，为一个正整数，或字符串”width-device”；initial-scale 设置页面的初始缩放值，为一个数字，可以带小数；minimum-scale允许用户的最小缩放值，为一个数字，可以带小数；maximum-scale 允许用户的最大缩放值，为一个数字，可以带小数；user-scalable 是否允许用户进行缩放，值为”no”或”yes”, no 代表不允许，yes代表允许。当然还可以设置其他的值，用逗号隔开就可以。 width和initial-scale在移动端页面中的作用（1）通过width=device-width，所有浏览器都能把当前的viewport宽度变成ideal viewport的宽度，但要注意的是，在iphone和ipad上，无论是竖屏还是横屏，宽度都是竖屏时ideal viewport的宽度。（2）initial-scale的缩放是相对于ideal viewport来进行缩放的，当对ideal viewport进行100%的缩放，也就是缩放值为1的时候，得到的就是ideal viewport（3）ideal viewport的值会取width和initial-scale两个中较大的那个值 关于initial-scale的缩放initial-scale是对页面就行缩放（个人理解就是缩放单位css像素的大小），测试如下，在meta中去掉width这一项，visual viewport得出如下数据：从上图可以看出，在屏幕宽度不变的情况下，当initial-scale变小，预示着css像素变小，导致填充整个屏幕需要的css像素就会变多。因此，我们可以得出一个公式：visual viewport宽度 = ideal viewport宽度 / 当前缩放值 关于width去掉initial-scale，测试width。当width=160时，这是因为有些元素把宽高都写死了，此时initial-scale=2，元素都变为原来的2倍，所以导致页面很挤。当width=1280时，这是因为有些元素把宽高都写死了，此时initial-scale=2，元素都变为原来的0.25倍，所以导致页面的元素很小。 结论在iphone和ipad上，无论你给viewport设的宽的是多少，如果没有指定默认的缩放值，则iphone和ipad会自动计算这个缩放值，以达到当前页面不会出现横向滚动条(或者说viewport的宽度就是屏幕的宽度)的目的。安卓设备上的initial-scale默认值好像没有方法能够得到，或者就是干脆它就没有默认值，一定要你显示的写出来这个东西才会起作用！ 利用meta.viewport对多屏适配布局retina下，border: 1px问题经常border：1px在不同手机上的宽度不一样，如下：上图中，对于一条1px宽的直线，它们在屏幕上的物理尺寸(灰色区域)的确是相同的，不同的其实是屏幕上最小的物理显示单元，即物理像素，所以对于一条直线，iphone5它能显示的最小宽度其实是图中的红线圈出来的灰色区域，用css来表示，理论上说是0.5px。所以，设计师想要的retina下border:1px;，其实就是1物理像素宽，对于css而言，可以认为是border: 0.5px;，这是retina下(dpr=2)下能显示的最小单位。 多屏适配布局移动端布局，为了适配各种大屏手机，目前最好用的方案莫过于使用相对单位rem。rem = document.documentElement.clientWidth * dpr / 10 javascript方式，通过上面的公式，计算出基准值rem，然后写入样式。 以下是淘宝的代码： (function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = 'orientationchange' in window ? 'orientationchange' : 'resize', recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; docEl.style.fontSize = 20 * (clientWidth / 320) + 'px'; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener('DOMContentLoaded', recalc, false);&#125;)(document, window); 可以看出，他们也仅仅按照手机屏幕的宽度在做适配，没有动用dpr和scale，个人认为这两个必须同时运用，页面才会在理想情况下展现！ 一般方法大概如下： var dpr, rem, scale;var docEl = document.documentElement;var fontEl = document.createElement('style');var metaEl = document.querySelector('meta[name="viewport"]');dpr = win.devicePixelRatio || 1;scale = 1 / dpr;rem = docEl.clientWidth * dpr / 10;// 设置viewport，进行缩放，达到高清效果metaEl.setAttribute('content', 'width=' + dpr * docEl.clientWidth + ',initial-scale=' + scale + ',maximum-scale=' + scale + ', minimum-scale=' + scale + ',user-scalable=no');// 设置data-dpr属性，留作的css hack之用docEl.setAttribute('data-dpr', dpr);// 动态写入样式docEl.firstElementChild.appendChild(fontEl);fontEl.innerHTML = 'html&#123;font-size:' + rem + 'px!important;&#125;';// 给js调用的，某一dpr下rem和px之间的转换函数window.rem2px = function(v) &#123; v = parseFloat(v); return v * rem;&#125;;window.px2rem: function(v) &#123; v = parseFloat(v); return v / rem;&#125;;window.dpr = dpr;window.rem = rem; 以上设置是为了保证，1个css像素占据一个物理像素。如果有一个区块，在psd文件中量出：宽高750×300px的div，那么如何转换成rem单位呢？如果scale是1，对于iphone6来说就是取一半，如果scale是0.5，量出多少是多少，换句话说就是设计稿的宽度W=docEl.clientWidth * dpr，对于不符合的设计稿，计算公式如下：我们现在写页面参考的机型一般是iphone4以上，dpr一般都是2，所以按照以上写法其实只有viewport的宽度在起作用，但是如果遇到宽度和dpr都不一样的时候，两者的倍数都会起作用，如果遇到iphone3这样的，宽度不变而dpr变化的，它上面的元素就会比iphone4要小，遇到这样的机型，如果不改变scale，样式有可能出问题！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[移动端之webp图片]]></title>
      <url>http://yoursite.com/2016/04/27/image-to-webp/</url>
      <content type="text"><![CDATA[webp是什么？WebP格式，谷歌（google）开发的一种旨在加快图片加载速度的图片格式。图片压缩体积大约只有JPEG的2/3，并能节省大量的服务器带宽资源和数据空间。Facebook Ebay等知名网站已经开始测试并使用WebP格式。但WebP是一种有损压缩。相较编码JPEG文件，编码同样质量的WebP文件需要占用更多的计算资源。 目前使用情况国外的网站：Youtube、Facebook.etc国内的网站：腾讯、淘宝、美团等 webp兼容性支持chrome opera4s uc5 uc5s uc6 uc6s uc华为荣耀6 qq内置浏览器 微信 uc 自带浏览器魅族 微信 uc 自带浏览器三星（Galay S4） uc 自带浏览器 QQ浏览器红米1s（andr4.3） uc QQ浏览器-v6.4.1 自带浏览器 不支持58app-v6.5.74s safari5 safari5s safari6 safari6s safari5s qq内置浏览器6 qq内置浏览器6s qq内置浏览器QQ浏览器-v6.0QQ浏览器-v6.45微信5s微信6微信6s微信5s 高速浏览器 如何转换智图iSpartalibwebp 如何使用js检测，准备两套图片路径var kTestImages = &#123; lossy: "UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", lossless: "UklGRhoAAABXRUJQVlA4TA0AAAAvAAAAEAcQERGIiP4HAA==", alpha: "UklGRkoAAABXRUJQVlA4WAoAAAAQAAAAAAAAAAAAQUxQSAwAAAARBxAR/Q9ERP8DAABWUDggGAAAABQBAJ0BKgEAAQAAAP4AAA3AAP7mtQAAAA==", animation: "UklGRlIAAABXRUJQVlA4WAoAAAASAAAAAAAAAAAAQU5JTQYAAAD/////AABBTk1GJgAAAAAAAAAAAAAAAAAAAGQAAABWUDhMDQAAAC8AAAAQBxAREYiI/gcA"&#125;;var img = new Image();img.onload = function () &#123; var result = (img.width &gt; 0) &amp;&amp; (img.height &gt; 0); callback(feature, result);&#125;;img.onerror = function () &#123; callback(feature, false);&#125;;img.src = "data:image/webp;base64," + kTestImages[feature];&#125; 使用webp.js插件将会捕捉页面中使用WebP格式的img元素，并用Flash进行替换。图像的解码及显示都在Flash中完成，因此目前版本对CSS设置的背景图片无效。当然，作为JPEG格式的替换，只有对较大的图像使用才有意义，否则过多的解码将消耗大量的资源。3、用html5中提供的picture元素选择图片格式（浏览器支持的情况不好） server-response（Accept和varry）Acceptiphone4suc无Accept请求头Safari Accept:*/*微信 Accept:*/*QQ浏览器-v6.4 Accept:*/*小米4uc：Accept:image/webp自带浏览器：Accept:image/webpchrome：Accept:image/webpQQ浏览器：Accept:image/webp并不是所有的请求头都包含images/webp 目前只有opera有 varry(client) &gt; Accept: image/jpeg, image/png, image/mif(server) &gt; Content-Type: image/mif &gt; Vary: Accept &gt; (object) 优势WebP is a new image format that provides lossless and lossy compression for images on the web. WebP lossless images are 26% smaller in size compared to PNGs. WebP lossy images are 25-34% smaller in size compared to JPEG images at equivalent SSIM index. WebP supports lossless transparency (also known as alpha channel) with just 22% additional bytes. Transparency is also supported with lossy compression and typically provides 3x smaller file sizes compared to PNG when lossy compression is acceptable for the red/green/blue color channels. 参考文献：WebP 探寻之路A new image format for the WebDeploying New Image Formats on the WebHow To Reduce Image Size With WebP Automagically让你的页面支持WebP图像]]></content>
    </entry>

    
  
  
</search>
